---
phase: 03-korean-specialization
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/korean/data/texture-library.json
  - src/korean/texture-library.ts
  - src/pipeline/quality-oracle.ts
  - src/pipeline/prose-surgeon.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Texture library contains categorized Korean onomatopoeia (의성어) and mimetic words (의태어)"
    - "Texture entries include verb forms (~거리다) where applicable"
    - "suggestTexture function matches texture to scene emotion/action context"
    - "Quality Oracle detects passages lacking Korean texture"
    - "texture-enrichment directives include contextually appropriate suggestions"
  artifacts:
    - path: "src/korean/data/texture-library.json"
      provides: "Categorized onomatopoeia and mimetic word database"
      contains: "두근두근"
    - path: "src/korean/texture-library.ts"
      provides: "Texture matching and suggestion engine"
      exports: ["suggestTexture", "assessTexturePresence", "TEXTURE_ENTRIES", "TextureEntry"]
    - path: "src/pipeline/quality-oracle.ts"
      provides: "Texture enrichment detection and directives"
      contains: "texture-enrichment"
    - path: "src/pipeline/prose-surgeon.ts"
      provides: "Model routing for texture-enrichment"
      contains: "texture-enrichment"
  key_links:
    - from: "src/korean/texture-library.ts"
      to: "src/korean/data/texture-library.json"
      via: "JSON import"
      pattern: "import.*texture-library\\.json"
    - from: "src/pipeline/quality-oracle.ts"
      to: "src/korean/texture-library.ts"
      via: "assessment function call"
      pattern: "assessTexturePresence|suggestTexture"
---

<objective>
Implement the Korean texture library for onomatopoeia (의성어), mimetic words (의태어), and prose texture enrichment.

Purpose: Korean prose gains richness and distinctiveness from sound-symbolic words that have no English equivalents. Without these, prose feels flat and un-Korean. Texture must feel natural, not decorative.

Output: Texture library JSON with categorized entries, texture matching module with context-based suggestions, Quality Oracle integration for 'texture-enrichment' directive type.
</objective>

<execution_context>
@C:\Users\jodnr\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jodnr\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-korean-specialization/03-RESEARCH.md

@src/pipeline/types.ts
@src/pipeline/quality-oracle.ts
@src/pipeline/prose-surgeon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Korean texture library data file and module</name>
  <files>
    src/korean/data/texture-library.json
    src/korean/texture-library.ts
  </files>
  <action>
**src/korean/data/texture-library.json:**
Comprehensive categorized texture library from research Appendix B:
```json
{
  "version": "1.0",
  "categories": {
    "emotion": {
      "heartbeat": [
        { "korean": "두근두근", "intensity": "medium", "verbForm": "두근거리다", "contexts": ["excitement", "nervousness", "anticipation", "romance"] },
        { "korean": "콩닥콩닥", "intensity": "soft", "verbForm": "콩닥거리다", "contexts": ["flutter", "nervousness", "shyness"] },
        { "korean": "쿵쿵", "intensity": "strong", "verbForm": "쿵쿵거리다", "contexts": ["fear", "anger", "intense emotion"] }
      ],
      "trembling": [
        { "korean": "부들부들", "intensity": "strong", "verbForm": "부들거리다", "contexts": ["anger", "fear", "cold"] },
        { "korean": "오들오들", "intensity": "medium", "verbForm": "오들거리다", "contexts": ["cold", "fear", "shivering"] },
        { "korean": "덜덜", "intensity": "strong", "verbForm": "덜덜거리다", "contexts": ["fear", "cold", "shock"] }
      ]
    },
    "sound": {
      "crying": [
        { "korean": "엉엉", "intensity": "strong", "verbForm": "엉엉거리다", "contexts": ["grief", "despair", "loud crying"] },
        { "korean": "훌쩍훌쩍", "intensity": "soft", "verbForm": "훌쩍거리다", "contexts": ["sadness", "sniffling", "quiet crying"] },
        { "korean": "흐느끼다", "intensity": "medium", "verbForm": null, "contexts": ["grief", "sobbing"] }
      ],
      "laughter": [
        { "korean": "낄낄", "intensity": "soft", "verbForm": "낄낄거리다", "contexts": ["giggling", "amusement", "mischief"] },
        { "korean": "깔깔", "intensity": "strong", "verbForm": "깔깔거리다", "contexts": ["hearty laughter", "amusement"] },
        { "korean": "킥킥", "intensity": "soft", "verbForm": "킥킥거리다", "contexts": ["suppressed laughter", "sneaky"] }
      ],
      "speaking": [
        { "korean": "속삭속삭", "intensity": "soft", "verbForm": "속삭거리다", "contexts": ["whispering", "secrets", "intimacy"] },
        { "korean": "중얼중얼", "intensity": "soft", "verbForm": "중얼거리다", "contexts": ["mumbling", "muttering", "thinking aloud"] },
        { "korean": "투덜투덜", "intensity": "medium", "verbForm": "투덜거리다", "contexts": ["complaining", "grumbling"] }
      ]
    },
    "movement": {
      "walking": [
        { "korean": "살금살금", "intensity": "soft", "verbForm": "살금거리다", "contexts": ["sneaking", "careful", "quiet"] },
        { "korean": "성큼성큼", "intensity": "strong", "verbForm": "성큼거리다", "contexts": ["striding", "determined", "urgent"] },
        { "korean": "터벅터벅", "intensity": "medium", "verbForm": "터벅거리다", "contexts": ["trudging", "tired", "heavy steps"] }
      ],
      "running": [
        { "korean": "쿵쿵", "intensity": "strong", "verbForm": "쿵쿵거리다", "contexts": ["stomping", "running", "heavy footsteps"] },
        { "korean": "달그락달그락", "intensity": "medium", "verbForm": "달그락거리다", "contexts": ["clattering", "rattling"] }
      ],
      "falling": [
        { "korean": "데굴데굴", "intensity": "medium", "verbForm": "데굴거리다", "contexts": ["rolling", "tumbling"] },
        { "korean": "휘청휘청", "intensity": "medium", "verbForm": "휘청거리다", "contexts": ["staggering", "unsteady", "dizzy"] },
        { "korean": "털썩", "intensity": "strong", "verbForm": null, "contexts": ["collapsing", "falling heavily"] }
      ]
    },
    "visual": {
      "light": [
        { "korean": "반짝반짝", "intensity": "soft", "verbForm": "반짝거리다", "contexts": ["sparkling", "twinkling", "eyes"] },
        { "korean": "번쩍번쩍", "intensity": "strong", "verbForm": "번쩍거리다", "contexts": ["flashing", "lightning", "bright"] },
        { "korean": "흐릿흐릿", "intensity": "soft", "verbForm": null, "contexts": ["blurry", "dim", "fading"] }
      ],
      "appearance": [
        { "korean": "알록달록", "intensity": "medium", "verbForm": null, "contexts": ["colorful", "varied", "patterned"] },
        { "korean": "끈적끈적", "intensity": "medium", "verbForm": "끈적거리다", "contexts": ["sticky", "gooey", "humid"] }
      ]
    },
    "nature": {
      "rain": [
        { "korean": "주룩주룩", "intensity": "medium", "verbForm": "주룩거리다", "contexts": ["rain", "pouring", "drizzling"] },
        { "korean": "후드득후드득", "intensity": "strong", "verbForm": null, "contexts": ["heavy rain", "pattering"] },
        { "korean": "보슬보슬", "intensity": "soft", "verbForm": null, "contexts": ["light rain", "drizzle", "gentle"] }
      ],
      "wind": [
        { "korean": "살랑살랑", "intensity": "soft", "verbForm": "살랑거리다", "contexts": ["gentle breeze", "swaying", "light wind"] },
        { "korean": "쏴아", "intensity": "medium", "verbForm": null, "contexts": ["rushing wind", "water rushing"] },
        { "korean": "휭", "intensity": "strong", "verbForm": null, "contexts": ["whoosh", "swift", "sudden wind"] }
      ],
      "sun": [
        { "korean": "쨍쨍", "intensity": "strong", "verbForm": null, "contexts": ["blazing sun", "hot", "bright day"] },
        { "korean": "따사로이", "intensity": "soft", "verbForm": null, "contexts": ["warm", "gentle sunshine", "cozy"] }
      ]
    }
  },
  "metadata": {
    "source": "Korean mimetic word research, TOPIK Guide, 나무위키",
    "lastUpdated": "2026-02-05",
    "note": "Use 1-2 texture words per 500 chars maximum to avoid forced feeling"
  }
}
```

**src/korean/texture-library.ts:**
Texture matching and suggestion module:
```typescript
import textureData from './data/texture-library.json' assert { type: 'json' };

export interface TextureEntry {
  korean: string;
  intensity: 'soft' | 'medium' | 'strong';
  verbForm: string | null;
  contexts: string[];
  category: string;
  subcategory: string;
}

export interface TextureSuggestion {
  texture: TextureEntry;
  reason: string;
  priority: number;
  useVerbForm: boolean;
}

export interface TextureContext {
  sceneEmotion: string[];   // e.g., ['sadness', 'loss']
  sceneAction: string[];    // e.g., ['crying', 'walking']
  genre?: string;           // e.g., 'romance', 'thriller'
  intensity?: 'soft' | 'medium' | 'strong';  // preferred intensity
}

// Flatten and load all texture entries
export const TEXTURE_ENTRIES: TextureEntry[] = [];

export function loadTextureLibrary(): void {
  TEXTURE_ENTRIES.length = 0;
  const data = textureData as any;
  for (const [category, subcategories] of Object.entries(data.categories)) {
    for (const [subcategory, entries] of Object.entries(subcategories as Record<string, any[]>)) {
      for (const entry of entries) {
        TEXTURE_ENTRIES.push({
          ...entry,
          category,
          subcategory,
        });
      }
    }
  }
}

// Initialize on module load
loadTextureLibrary();

/**
 * Suggest texture words based on scene context
 * @param context - Scene emotion and action context
 * @param maxSuggestions - Maximum suggestions to return (default: 3)
 */
export function suggestTexture(
  context: TextureContext,
  maxSuggestions: number = 3
): TextureSuggestion[] {
  const suggestions: TextureSuggestion[] = [];

  // Match by emotion context
  for (const emotion of context.sceneEmotion) {
    const matches = TEXTURE_ENTRIES.filter(t =>
      t.contexts.some(c => c.toLowerCase().includes(emotion.toLowerCase()))
    );

    for (const match of matches) {
      if (context.intensity && match.intensity !== context.intensity) continue;

      suggestions.push({
        texture: match,
        reason: `Matches scene emotion: ${emotion}`,
        priority: 1,
        useVerbForm: match.verbForm !== null && shouldUseVerbForm(context),
      });
    }
  }

  // Match by action context
  for (const action of context.sceneAction) {
    const matches = TEXTURE_ENTRIES.filter(t =>
      t.subcategory.toLowerCase().includes(action.toLowerCase()) ||
      t.contexts.some(c => c.toLowerCase().includes(action.toLowerCase()))
    );

    for (const match of matches) {
      // Skip if already suggested
      if (suggestions.some(s => s.texture.korean === match.korean)) continue;
      if (context.intensity && match.intensity !== context.intensity) continue;

      suggestions.push({
        texture: match,
        reason: `Matches scene action: ${action}`,
        priority: 2,
        useVerbForm: match.verbForm !== null && shouldUseVerbForm(context),
      });
    }
  }

  // Sort by priority and limit
  return suggestions
    .sort((a, b) => a.priority - b.priority)
    .slice(0, maxSuggestions);
}

function shouldUseVerbForm(context: TextureContext): boolean {
  // Prefer verb forms when action is primary
  return context.sceneAction.length > 0;
}

/**
 * Assess texture presence in content
 * @param content - Text to analyze
 * @param targetPer500Chars - Target texture count per 500 chars (default: 1)
 */
export function assessTexturePresence(
  content: string,
  targetPer500Chars: number = 1
): {
  score: number;
  textureCount: number;
  foundTextures: string[];
  deficientSegments: Array<{ start: number; end: number }>;
} {
  const foundTextures: string[] = [];

  // Find all texture words in content
  for (const entry of TEXTURE_ENTRIES) {
    if (content.includes(entry.korean)) {
      foundTextures.push(entry.korean);
    }
    if (entry.verbForm && content.includes(entry.verbForm)) {
      foundTextures.push(entry.verbForm);
    }
  }

  const charCount = content.length;
  const segments = Math.ceil(charCount / 500);
  const deficientSegments: Array<{ start: number; end: number }> = [];

  // Check each 500-char segment
  for (let i = 0; i < segments; i++) {
    const start = i * 500;
    const end = Math.min(start + 500, charCount);
    const segment = content.slice(start, end);

    let segmentTextureCount = 0;
    for (const entry of TEXTURE_ENTRIES) {
      if (segment.includes(entry.korean)) segmentTextureCount++;
      if (entry.verbForm && segment.includes(entry.verbForm)) segmentTextureCount++;
    }

    if (segmentTextureCount < targetPer500Chars) {
      deficientSegments.push({ start, end });
    }
  }

  // Calculate score (higher is better)
  const idealCount = segments * targetPer500Chars;
  const score = Math.min(100, Math.round((foundTextures.length / Math.max(1, idealCount)) * 100));

  return {
    score,
    textureCount: foundTextures.length,
    foundTextures: [...new Set(foundTextures)], // Deduplicate
    deficientSegments,
  };
}

/**
 * Get texture entries by category
 */
export function getTexturesByCategory(category: string): TextureEntry[] {
  return TEXTURE_ENTRIES.filter(t => t.category === category);
}

/**
 * Get texture entries by context keyword
 */
export function getTexturesByContext(contextKeyword: string): TextureEntry[] {
  return TEXTURE_ENTRIES.filter(t =>
    t.contexts.some(c => c.toLowerCase().includes(contextKeyword.toLowerCase()))
  );
}
```
  </action>
  <verify>
    npm run build succeeds
    Files exist at src/korean/data/texture-library.json and src/korean/texture-library.ts
    JSON is valid and contains entries for all 5 main categories
  </verify>
  <done>
    Texture library contains 40+ entries across 5 categories
    Entries include verb forms where applicable
    suggestTexture matches by emotion and action context
    assessTexturePresence identifies segments lacking texture
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate texture assessment with Quality Oracle and Prose Surgeon</name>
  <files>
    src/pipeline/quality-oracle.ts
    src/pipeline/prose-surgeon.ts
  </files>
  <action>
**src/pipeline/quality-oracle.ts:**
1. Import texture library functions:
   ```typescript
   import { assessTexturePresence, suggestTexture, type TextureContext } from '../korean/texture-library.js';
   ```

2. Extend options type for analyzeChapter:
   ```typescript
   options?: {
     honorificMatrix?: HonorificMatrix;
     dialogueAttributions?: Map<number, string>;
     detectBannedExpressions?: boolean;
     bannedExpressionMinSeverity?: 'critical' | 'high' | 'medium' | 'low';
     assessKoreanTexture?: boolean;  // default true
     textureContext?: TextureContext;  // scene emotion/action for suggestions
   }
   ```

3. Add texture assessment section in analyzeChapter (after sensory analysis, as related enrichment):
   ```typescript
   // 2b. Korean texture assessment
   const textureAssessment = options?.assessKoreanTexture !== false
     ? assessTexturePresence(content)
     : { score: 100, textureCount: 0, foundTextures: [], deficientSegments: [] };

   // Create texture-enrichment directives (max 1 per pass, lowest priority)
   if (textureAssessment.deficientSegments.length > 0 && directives.length < MAX_DIRECTIVES_PER_PASS) {
     const segment = textureAssessment.deficientSegments[0];
     const startPara = findParagraphForPosition(paragraphs, segment.start);
     const endPara = findParagraphForPosition(paragraphs, segment.end);
     const targetParas = paragraphs.slice(startPara, endPara + 1);
     const currentText = targetParas.map(p => p.text).join('\n\n').slice(0, 500);

     // Get contextual suggestions if context provided
     const suggestions = options?.textureContext
       ? suggestTexture(options.textureContext, 2)
       : [];

     const suggestionText = suggestions.length > 0
       ? `추천 의성어/의태어: ${suggestions.map(s => s.useVerbForm && s.texture.verbForm ? s.texture.verbForm : s.texture.korean).join(', ')}`
       : '장면 감정/동작에 맞는 의성어/의태어를 자연스럽게 추가하세요';

     directives.push(createDirective(
       'texture-enrichment',
       6, // Lowest priority (enhancement not fix)
       {
         sceneNumber: Math.min(Math.ceil((startPara + 1) / Math.max(1, paragraphs.length / sceneCount)), sceneCount),
         paragraphStart: startPara,
         paragraphEnd: Math.min(endPara, startPara + 2),
       },
       `이 구간에 한국어 고유 텍스처(의성어/의태어)가 부족합니다`,
       currentText,
       `${suggestionText}. 주의: 장식적이 아닌 자연스러운 삽입이 중요합니다. 500자당 1-2개 이하.`,
       2
     ));
   }
   ```

4. Add to QualityAssessment interface:
   ```typescript
   koreanTexture?: {
     score: number;
     textureCount: number;
     foundTextures: string[];
   };
   ```

5. Include texture in assessment output (populate from textureAssessment).

**src/pipeline/prose-surgeon.ts:**
1. Add model routing for 'texture-enrichment':
   ```typescript
   'texture-enrichment': { model: 'opus', temperature: 0.7 },  // Creative task
   ```

2. Add scope limit:
   ```typescript
   'texture-enrichment': 2,  // Up to 2 paragraphs
   ```
  </action>
  <verify>
    npm run build succeeds
    npm test passes
    analyzeChapter with assessKoreanTexture: true detects texture-lacking passages
    texture-enrichment directives include contextual suggestions when textureContext provided
  </verify>
  <done>
    Quality Oracle assesses Korean texture presence
    Texture-deficient segments generate 'texture-enrichment' directives
    Directives include contextually appropriate suggestions
    Prose Surgeon routes texture-enrichment to Opus with moderate temperature
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for texture library functionality</name>
  <files>
    tests/korean/texture-library.test.ts
  </files>
  <action>
Create test file `tests/korean/texture-library.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import {
  TEXTURE_ENTRIES,
  suggestTexture,
  assessTexturePresence,
  getTexturesByCategory,
  getTexturesByContext,
  type TextureContext,
} from '../../src/korean/texture-library.js';

describe('texture-library', () => {
  describe('TEXTURE_ENTRIES', () => {
    it('loads entries from JSON', () => {
      expect(TEXTURE_ENTRIES.length).toBeGreaterThan(30);
    });

    it('includes all main categories', () => {
      const categories = new Set(TEXTURE_ENTRIES.map(e => e.category));
      expect(categories.has('emotion')).toBe(true);
      expect(categories.has('sound')).toBe(true);
      expect(categories.has('movement')).toBe(true);
      expect(categories.has('visual')).toBe(true);
      expect(categories.has('nature')).toBe(true);
    });

    it('includes verb forms where applicable', () => {
      const withVerbForms = TEXTURE_ENTRIES.filter(e => e.verbForm !== null);
      expect(withVerbForms.length).toBeGreaterThan(20);
      expect(withVerbForms.some(e => e.verbForm?.includes('거리다'))).toBe(true);
    });

    it('includes classic Korean onomatopoeia', () => {
      expect(TEXTURE_ENTRIES.some(e => e.korean === '두근두근')).toBe(true);
      expect(TEXTURE_ENTRIES.some(e => e.korean === '엉엉')).toBe(true);
      expect(TEXTURE_ENTRIES.some(e => e.korean === '살금살금')).toBe(true);
    });
  });

  describe('suggestTexture', () => {
    it('suggests textures matching emotion context', () => {
      const context: TextureContext = {
        sceneEmotion: ['sadness', 'grief'],
        sceneAction: [],
      };
      const suggestions = suggestTexture(context);
      expect(suggestions.length).toBeGreaterThan(0);
      // Should include crying-related textures
      expect(suggestions.some(s =>
        s.texture.contexts.some(c => c.includes('grief') || c.includes('sadness'))
      )).toBe(true);
    });

    it('suggests textures matching action context', () => {
      const context: TextureContext = {
        sceneEmotion: [],
        sceneAction: ['walking', 'sneaking'],
      };
      const suggestions = suggestTexture(context);
      expect(suggestions.length).toBeGreaterThan(0);
      expect(suggestions.some(s => s.texture.subcategory === 'walking')).toBe(true);
    });

    it('respects intensity preference', () => {
      const softContext: TextureContext = {
        sceneEmotion: ['nervousness'],
        sceneAction: [],
        intensity: 'soft',
      };
      const suggestions = suggestTexture(softContext);
      // All suggestions should be soft intensity
      expect(suggestions.every(s => s.texture.intensity === 'soft')).toBe(true);
    });

    it('limits suggestions to maxSuggestions', () => {
      const context: TextureContext = {
        sceneEmotion: ['fear', 'anger', 'sadness'],
        sceneAction: ['running', 'crying'],
      };
      const suggestions = suggestTexture(context, 2);
      expect(suggestions.length).toBeLessThanOrEqual(2);
    });

    it('recommends verb forms for action contexts', () => {
      const context: TextureContext = {
        sceneEmotion: [],
        sceneAction: ['walking'],
      };
      const suggestions = suggestTexture(context);
      const withVerbForm = suggestions.filter(s => s.useVerbForm && s.texture.verbForm);
      expect(withVerbForm.length).toBeGreaterThan(0);
    });
  });

  describe('assessTexturePresence', () => {
    it('detects texture words in content', () => {
      const content = '그녀의 심장이 두근두근 뛰었다. 빗방울이 주룩주룩 떨어졌다.';
      const assessment = assessTexturePresence(content);
      expect(assessment.textureCount).toBeGreaterThanOrEqual(2);
      expect(assessment.foundTextures).toContain('두근두근');
      expect(assessment.foundTextures).toContain('주룩주룩');
    });

    it('detects verb forms as texture', () => {
      const content = '그는 살금살금거리며 방으로 들어갔다.';
      const assessment = assessTexturePresence(content);
      expect(assessment.textureCount).toBeGreaterThanOrEqual(1);
    });

    it('identifies deficient segments', () => {
      const content = '그는 문을 열었다. 방 안은 어두웠다. 창문으로 달빛이 들어왔다. ' +
        '그녀가 의자에 앉아 있었다. 그는 천천히 다가갔다.';
      const assessment = assessTexturePresence(content);
      // Short content with no texture should have deficient segments
      expect(assessment.deficientSegments.length).toBeGreaterThan(0);
    });

    it('returns high score for texture-rich content', () => {
      const content = '심장이 두근두근 뛰었다. 발걸음이 살금살금. ' +
        '눈물이 훌쩍훌쩍. 바람이 살랑살랑 불었다.';
      const assessment = assessTexturePresence(content, 1);
      expect(assessment.score).toBeGreaterThanOrEqual(80);
    });
  });

  describe('getTexturesByCategory', () => {
    it('filters by category', () => {
      const emotions = getTexturesByCategory('emotion');
      expect(emotions.length).toBeGreaterThan(0);
      expect(emotions.every(e => e.category === 'emotion')).toBe(true);
    });
  });

  describe('getTexturesByContext', () => {
    it('finds textures by context keyword', () => {
      const fearTextures = getTexturesByContext('fear');
      expect(fearTextures.length).toBeGreaterThan(0);
      expect(fearTextures.every(t =>
        t.contexts.some(c => c.toLowerCase().includes('fear'))
      )).toBe(true);
    });
  });
});
```
  </action>
  <verify>
    npm test -- tests/korean/texture-library.test.ts passes
    All category, suggestion, and assessment tests pass
  </verify>
  <done>
    Test file exists with comprehensive coverage
    All tests pass
    Texture matching verified for emotion and action contexts
    Deficient segment detection verified
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm test` passes all existing and new tests
3. Texture library contains 40+ categorized entries
4. Quality Oracle detects texture-lacking passages
5. texture-enrichment directives include contextual suggestions
6. Prose Surgeon MODEL_ROUTING includes 'texture-enrichment'
</verification>

<success_criteria>
- Texture library JSON contains 40+ entries in 5 categories (emotion, sound, movement, visual, nature)
- Entries include Korean text, intensity, verb form, and context keywords
- suggestTexture returns contextually appropriate suggestions
- assessTexturePresence identifies texture-deficient segments
- Quality Oracle generates 'texture-enrichment' surgical directives
- Suggestions in directives match scene emotion/action context when provided
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-korean-specialization/03-03-SUMMARY.md`
</output>
