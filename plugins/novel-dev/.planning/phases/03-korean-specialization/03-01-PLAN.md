---
phase: 03-korean-specialization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/korean/types.ts
  - src/korean/honorific-matrix.ts
  - src/pipeline/types.ts
  - src/pipeline/quality-oracle.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Honorific matrix tracks per-character-pair speech levels (해체, 해요체, 하십시오체)"
    - "Speech level lookups return correct level for any speaker-listener pair"
    - "Context overrides (public, private, emotional) modify default speech levels"
    - "Quality Oracle detects honorific violations in dialogue"
  artifacts:
    - path: "src/korean/types.ts"
      provides: "Korean-specific type definitions"
      exports: ["SpeechLevel", "RelationshipSpeechLevel", "HonorificMatrix", "CharacterHonorificProfile", "HonorificViolation"]
    - path: "src/korean/honorific-matrix.ts"
      provides: "Honorific relationship tracking"
      exports: ["initializeHonorificMatrix", "getSpeechLevel", "detectHonorificViolations"]
    - path: "src/pipeline/types.ts"
      provides: "Extended DirectiveType with honorific-violation"
      contains: "honorific-violation"
    - path: "src/pipeline/quality-oracle.ts"
      provides: "Honorific violation detection integration"
      contains: "detectHonorificViolations"
  key_links:
    - from: "src/korean/honorific-matrix.ts"
      to: "src/korean/types.ts"
      via: "type imports"
      pattern: "import.*from.*types"
    - from: "src/pipeline/quality-oracle.ts"
      to: "src/korean/honorific-matrix.ts"
      via: "detection function call"
      pattern: "detectHonorificViolations"
---

<objective>
Implement the honorific relationship matrix system for tracking per-character speech levels in Korean fiction.

Purpose: Characters must maintain consistent honorific/speech levels based on relationships. Without this, dialogue breaks immersion when characters randomly switch between 반말 and 존댓말.

Output: Korean types module, honorific matrix module with initialization/lookup/detection functions, Quality Oracle integration for 'honorific-violation' directive type.
</objective>

<execution_context>
@C:\Users\jodnr\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jodnr\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-korean-specialization/03-RESEARCH.md

@src/pipeline/types.ts
@src/pipeline/quality-oracle.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Korean types and honorific matrix module</name>
  <files>
    src/korean/types.ts
    src/korean/honorific-matrix.ts
  </files>
  <action>
Create `src/korean/` directory and two files:

**src/korean/types.ts:**
Define Korean-specific types following the research patterns:
- `SpeechLevel`: Union type for 'haeche' | 'haeyoche' | 'hapsyoche' (modern 3 levels only)
- `CharacterHonorificProfile`: id, age, socialStatus, defaultSpeechToStrangers
- `RelationshipSpeechLevel`: speakerId, listenerId, defaultLevel, contextOverrides (public?, private?, emotional?)
- `HonorificMatrix`: characters Map<string, CharacterHonorificProfile>, relationships Map<string, RelationshipSpeechLevel>
- `HonorificViolation`: speakerId, listenerId, expectedLevel, actualLevel, position, dialogueText
- `KoreanDirectiveType`: Union extending existing DirectiveType with 'honorific-violation' | 'banned-expression' | 'texture-enrichment'

**src/korean/honorific-matrix.ts:**
Implement honorific tracking functions:
1. `initializeHonorificMatrix(characters: Character[]): HonorificMatrix`
   - Create CharacterHonorificProfile for each character
   - Derive relationships using `deriveSpeechLevel` based on age/status
   - Key format: `{speakerId}_to_{listenerId}`

2. `deriveSpeechLevel(speaker, listener): SpeechLevel`
   - Age diff > 5 years older: 'haeche' (casual to younger)
   - Age diff > 5 years younger: 'haeyoche' (polite to older)
   - Similar age: 'haeyoche' (default polite)

3. `getSpeechLevel(matrix, speakerId, listenerId, context?: 'public' | 'private' | 'emotional'): SpeechLevel`
   - Lookup relationship, apply context override if present

4. `detectHonorificViolations(content: string, matrix: HonorificMatrix, dialogueAttributions: Map<number, string>): HonorificViolation[]`
   - Extract dialogue using Korean quote marks ("", '', "")
   - For each dialogue with known speaker, detect speech level from verb endings
   - Compare against expected level from matrix
   - Return violations with position and text

Use speech level detection patterns:
- 해체: /-해$/, /-야$/, /-어$/, /-아$/
- 해요체: /-해요$/, /-요$/, /-어요$/, /-아요$/
- 하십시오체: /-합니다$/, /-습니다$/, /-입니다$/

Import Character type from `../../types.js` (existing project type).
  </action>
  <verify>
    npm run build succeeds without type errors
    Files exist at src/korean/types.ts and src/korean/honorific-matrix.ts
  </verify>
  <done>
    HonorificMatrix can be initialized from Character array
    getSpeechLevel returns correct level for speaker-listener pairs with context overrides
    detectHonorificViolations identifies mismatched speech levels in dialogue
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend DirectiveType and integrate with Quality Oracle</name>
  <files>
    src/pipeline/types.ts
    src/pipeline/quality-oracle.ts
  </files>
  <action>
**src/pipeline/types.ts:**
Extend the DirectiveType union to include Korean-specific types:
```typescript
export type DirectiveType =
  | 'show-not-tell'
  | 'filter-word-removal'
  | 'sensory-enrichment'
  | 'rhythm-variation'
  | 'dialogue-subtext'
  | 'cliche-replacement'
  | 'transition-smoothing'
  | 'voice-consistency'
  | 'proofreading'
  // Korean specialization (Phase 3)
  | 'honorific-violation'
  | 'banned-expression'
  | 'texture-enrichment';
```

**src/pipeline/quality-oracle.ts:**
1. Import from korean module:
   ```typescript
   import { detectHonorificViolations, type HonorificMatrix } from '../korean/honorific-matrix.js';
   ```

2. Add optional `honorificMatrix` parameter to `analyzeChapter`:
   ```typescript
   export function analyzeChapter(
     content: string,
     sceneCount: number = 1,
     options?: { honorificMatrix?: HonorificMatrix; dialogueAttributions?: Map<number, string> }
   ): QualityOracleResult
   ```

3. Inside analyzeChapter, add honorific analysis section after rhythm analysis:
   - If options.honorificMatrix provided, call detectHonorificViolations
   - Create 'honorific-violation' directives (priority 2, maxScope 1)
   - Limit to 2 directives per pass
   - Directive issue format: `캐릭터 {speaker}가 {listener}에게 {expected} 대신 {actual} 사용`
   - Instruction: `대화 종결어미를 {expected}체로 수정하세요. 문맥상 의도적 변화가 아니라면 일관성 유지.`

4. Update the verdict calculation to include honorific violations as a factor.

5. Add to QualityAssessment interface:
   ```typescript
   honorificConsistency?: {
     score: number;
     violations: string[];
   };
   ```
  </action>
  <verify>
    npm run build succeeds
    npm test passes (existing tests should not break)
    analyzeChapter with honorificMatrix option produces honorific-violation directives
  </verify>
  <done>
    DirectiveType includes 'honorific-violation', 'banned-expression', 'texture-enrichment'
    Quality Oracle detects honorific violations when matrix provided
    Violations generate surgical directives with Korean instructions
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for honorific matrix functionality</name>
  <files>
    tests/korean/honorific-matrix.test.ts
  </files>
  <action>
Create test file `tests/korean/honorific-matrix.test.ts`:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import {
  initializeHonorificMatrix,
  getSpeechLevel,
  detectHonorificViolations,
  deriveSpeechLevel
} from '../../src/korean/honorific-matrix.js';

describe('honorific-matrix', () => {
  describe('deriveSpeechLevel', () => {
    it('returns haeche when speaker is 6+ years older', () => {
      const speaker = { id: 'a', age: 30, socialStatus: 'adult' };
      const listener = { id: 'b', age: 23, socialStatus: 'student' };
      expect(deriveSpeechLevel(speaker, listener)).toBe('haeche');
    });

    it('returns haeyoche when speaker is 6+ years younger', () => {
      const speaker = { id: 'a', age: 20, socialStatus: 'student' };
      const listener = { id: 'b', age: 35, socialStatus: 'teacher' };
      expect(deriveSpeechLevel(speaker, listener)).toBe('haeyoche');
    });

    it('returns haeyoche for similar ages', () => {
      const speaker = { id: 'a', age: 25, socialStatus: 'adult' };
      const listener = { id: 'b', age: 27, socialStatus: 'adult' };
      expect(deriveSpeechLevel(speaker, listener)).toBe('haeyoche');
    });
  });

  describe('initializeHonorificMatrix', () => {
    it('creates profiles for all characters', () => {
      const chars = [
        { id: 'kim', name: '김철수', age: 35, socialStatus: 'boss' },
        { id: 'lee', name: '이영희', age: 28, socialStatus: 'employee' },
      ];
      const matrix = initializeHonorificMatrix(chars);
      expect(matrix.characters.size).toBe(2);
      expect(matrix.characters.get('kim')).toBeDefined();
    });

    it('creates bidirectional relationships', () => {
      const chars = [
        { id: 'kim', name: '김철수', age: 35, socialStatus: 'boss' },
        { id: 'lee', name: '이영희', age: 28, socialStatus: 'employee' },
      ];
      const matrix = initializeHonorificMatrix(chars);
      expect(matrix.relationships.has('kim_to_lee')).toBe(true);
      expect(matrix.relationships.has('lee_to_kim')).toBe(true);
    });
  });

  describe('getSpeechLevel', () => {
    it('returns default level without context', () => {
      const chars = [
        { id: 'kim', age: 35, socialStatus: 'boss' },
        { id: 'lee', age: 28, socialStatus: 'employee' },
      ];
      const matrix = initializeHonorificMatrix(chars);
      // Kim (older) to Lee (younger) -> haeche
      expect(getSpeechLevel(matrix, 'kim', 'lee')).toBe('haeche');
    });

    it('applies context override when present', () => {
      const chars = [
        { id: 'kim', age: 35, socialStatus: 'boss' },
        { id: 'lee', age: 28, socialStatus: 'employee' },
      ];
      const matrix = initializeHonorificMatrix(chars);
      // Manually set override
      const rel = matrix.relationships.get('kim_to_lee');
      if (rel) rel.contextOverrides = { public: 'haeyoche' };
      expect(getSpeechLevel(matrix, 'kim', 'lee', 'public')).toBe('haeyoche');
    });
  });

  describe('detectHonorificViolations', () => {
    it('detects speech level mismatch in dialogue', () => {
      const chars = [
        { id: 'senior', age: 45, socialStatus: 'senior' },
        { id: 'junior', age: 25, socialStatus: 'junior' },
      ];
      const matrix = initializeHonorificMatrix(chars);
      // Junior should use haeyoche to senior, but uses haeche
      const content = '"밥 먹었어?" 후배가 선배에게 물었다.';
      const attributions = new Map([[0, 'junior']]); // dialogue at 0 is from junior
      // Expected: junior->senior should be haeyoche, but "먹었어" is haeche
      const violations = detectHonorificViolations(content, matrix, attributions);
      expect(violations.length).toBeGreaterThan(0);
    });

    it('returns empty for correct speech levels', () => {
      const chars = [
        { id: 'senior', age: 45, socialStatus: 'senior' },
        { id: 'junior', age: 25, socialStatus: 'junior' },
      ];
      const matrix = initializeHonorificMatrix(chars);
      const content = '"밥 드셨어요?" 후배가 선배에게 물었다.';
      const attributions = new Map([[0, 'junior']]);
      const violations = detectHonorificViolations(content, matrix, attributions);
      expect(violations.length).toBe(0);
    });
  });
});
```

Adjust imports and test cases as needed to match actual function signatures.
  </action>
  <verify>
    npm test -- tests/korean/honorific-matrix.test.ts passes
    All test cases cover derivation, initialization, lookup, and detection
  </verify>
  <done>
    Test file exists with comprehensive coverage
    All tests pass
    Edge cases covered (context overrides, bidirectional relationships)
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm test` passes all existing and new tests
3. New Korean module exports are accessible
4. Quality Oracle produces 'honorific-violation' directives when matrix provided
</verification>

<success_criteria>
- HonorificMatrix initialized from Character array
- Per-pair speech levels derived from age/status
- Context overrides (public, private, emotional) work correctly
- detectHonorificViolations finds speech level mismatches
- Quality Oracle generates 'honorific-violation' surgical directives
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-korean-specialization/03-01-SUMMARY.md`
</output>
