---
phase: 03-korean-specialization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/korean/banned-expressions.ts
  - src/korean/data/banned-expressions.json
  - src/pipeline/quality-oracle.ts
  - src/pipeline/prose-surgeon.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Banned expression detection identifies AI-tell patterns (한편, 그러나, ~하였다)"
    - "Translationese patterns are detected with appropriate severity"
    - "Detection respects narration vs dialogue context"
    - "Quality Oracle produces banned-expression directives with replacement suggestions"
    - "Prose Surgeon routes banned-expression fixes to appropriate model"
  artifacts:
    - path: "src/korean/data/banned-expressions.json"
      provides: "Categorized banned expression lists"
      contains: "ai-tell"
    - path: "src/korean/banned-expressions.ts"
      provides: "Banned expression detection engine"
      exports: ["detectBannedExpressions", "BANNED_EXPRESSIONS", "BannedExpressionMatch"]
    - path: "src/pipeline/quality-oracle.ts"
      provides: "Banned expression directive generation"
      contains: "banned-expression"
    - path: "src/pipeline/prose-surgeon.ts"
      provides: "Model routing for banned-expression"
      contains: "banned-expression"
  key_links:
    - from: "src/korean/banned-expressions.ts"
      to: "src/korean/data/banned-expressions.json"
      via: "JSON import"
      pattern: "import.*banned-expressions\\.json"
    - from: "src/pipeline/quality-oracle.ts"
      to: "src/korean/banned-expressions.ts"
      via: "detection function call"
      pattern: "detectBannedExpressions"
---

<objective>
Implement the AI banned expression detection and replacement engine for Korean prose.

Purpose: AI-generated Korean text has detectable patterns (한편, 그러나 with commas, ~하였다 endings, translationese). These must be caught and replaced at generation time to achieve human-indistinguishable prose.

Output: Banned expressions JSON data file, detection module with categorized severity, Quality Oracle integration for 'banned-expression' directive type, Prose Surgeon model routing.
</objective>

<execution_context>
@C:\Users\jodnr\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jodnr\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-korean-specialization/03-RESEARCH.md

@src/pipeline/types.ts
@src/pipeline/quality-oracle.ts
@src/pipeline/prose-surgeon.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create banned expressions data file and detection module</name>
  <files>
    src/korean/data/banned-expressions.json
    src/korean/banned-expressions.ts
  </files>
  <action>
Create `src/korean/data/` directory and files:

**src/korean/data/banned-expressions.json:**
Comprehensive categorized banned expression list from research:
```json
{
  "version": "1.0",
  "categories": {
    "ai-tell": {
      "description": "AI-generated text characteristic connectors",
      "severity": "critical",
      "expressions": [
        { "pattern": "한편,", "replacements": ["", "그때", "그런데"], "context": "narration" },
        { "pattern": "그러나,", "replacements": ["하지만", "그런데", ""], "context": "narration" },
        { "pattern": "따라서,", "replacements": ["그래서", ""], "context": "narration" },
        { "pattern": "결과적으로", "replacements": ["결국", ""], "context": "narration" }
      ]
    },
    "archaic-verb": {
      "description": "Archaic/formal verb forms that sound AI-generated",
      "severity": "critical",
      "expressions": [
        { "pattern": "하였다", "isRegex": true, "regexPattern": "하였다\\.?$", "replacements": ["했다"], "context": "any" },
        { "pattern": "되었다", "isRegex": true, "regexPattern": "되었다\\.?$", "replacements": ["됐다"], "context": "any" },
        { "pattern": "있었다", "isRegex": true, "regexPattern": "있었다\\.?$", "replacements": ["있었다"], "context": "any", "note": "context-dependent" }
      ]
    },
    "translationese": {
      "description": "Patterns typical of translated text",
      "severity": "high",
      "expressions": [
        { "pattern": "인 것 중 하나", "replacements": ["대표적인", "인 것 하나"], "context": "narration" },
        { "pattern": "에 있어서", "replacements": ["에서", "에"], "context": "any" },
        { "pattern": "에 있어", "replacements": ["에서", "에"], "context": "any" },
        { "pattern": "로 인한", "replacements": ["때문에", "로"], "context": "any" },
        { "pattern": "으로 인한", "replacements": ["때문에", "으로"], "context": "any" },
        { "pattern": "하지 않을 수 없다", "replacements": ["해야 한다", "어쩔 수 없이"], "context": "any" }
      ]
    },
    "punctuation": {
      "description": "AI-characteristic comma placement",
      "severity": "medium",
      "expressions": [
        { "pattern": ", 그리고 ", "replacements": ["그리고 ", " 그리고 "], "context": "any" },
        { "pattern": ", 그러나 ", "replacements": [". 그러나 ", "그러나 "], "context": "any" },
        { "pattern": ", 따라서 ", "replacements": [". 따라서 ", "따라서 "], "context": "any" }
      ]
    },
    "pronoun-overuse": {
      "description": "Overuse of pronouns (translationese pattern)",
      "severity": "low",
      "expressions": [
        { "pattern": "그녀는", "replacements": ["[name]은", ""], "context": "narration", "note": "replace with character name or omit" },
        { "pattern": "그는", "replacements": ["[name]은", ""], "context": "narration", "note": "replace with character name or omit" }
      ]
    }
  },
  "metadata": {
    "source": "KatFishNet research, 나무위키 번역체",
    "lastUpdated": "2026-02-05"
  }
}
```

**src/korean/banned-expressions.ts:**
Detection engine with severity-based filtering:
```typescript
import bannedExpressionsData from './data/banned-expressions.json' assert { type: 'json' };
import type { KoreanDirectiveType } from './types.js';

export type BannedCategory = 'ai-tell' | 'archaic-verb' | 'translationese' | 'punctuation' | 'pronoun-overuse';
export type Severity = 'critical' | 'high' | 'medium' | 'low';
export type Context = 'narration' | 'dialogue' | 'any';

export interface BannedExpression {
  pattern: string;
  isRegex?: boolean;
  regexPattern?: string;
  replacements: string[];
  context: Context;
  note?: string;
}

export interface BannedExpressionMatch {
  expression: BannedExpression;
  category: BannedCategory;
  severity: Severity;
  position: number;
  matchedText: string;
  inDialogue: boolean;
}

// Load and flatten expressions for detection
export const BANNED_EXPRESSIONS: Array<BannedExpression & { category: BannedCategory; severity: Severity }> = [];
// (initialization code that flattens the JSON structure)

export function loadBannedExpressions(): void {
  BANNED_EXPRESSIONS.length = 0;
  const data = bannedExpressionsData as any;
  for (const [category, info] of Object.entries(data.categories)) {
    const catInfo = info as { severity: Severity; expressions: BannedExpression[] };
    for (const expr of catInfo.expressions) {
      BANNED_EXPRESSIONS.push({
        ...expr,
        category: category as BannedCategory,
        severity: catInfo.severity,
      });
    }
  }
}

// Initialize on module load
loadBannedExpressions();

/**
 * Detect banned expressions in content
 * @param content - Text to analyze
 * @param contextType - Whether analyzing narration or dialogue
 * @param minSeverity - Minimum severity to report (default: 'medium')
 */
export function detectBannedExpressions(
  content: string,
  contextType: 'narration' | 'dialogue' = 'narration',
  minSeverity: Severity = 'medium'
): BannedExpressionMatch[] {
  const severityOrder: Record<Severity, number> = { critical: 0, high: 1, medium: 2, low: 3 };
  const minLevel = severityOrder[minSeverity];

  // Detect dialogue ranges (same logic as quality-oracle.ts)
  const dialogueRanges: Array<{ start: number; end: number }> = [];
  const quotePattern = /["""]([^"""]*)["""]/g;
  let match;
  while ((match = quotePattern.exec(content)) !== null) {
    dialogueRanges.push({ start: match.index, end: match.index + match[0].length });
  }

  const isInDialogue = (pos: number): boolean =>
    dialogueRanges.some(range => pos >= range.start && pos <= range.end);

  const matches: BannedExpressionMatch[] = [];

  for (const expr of BANNED_EXPRESSIONS) {
    // Skip if severity below threshold
    if (severityOrder[expr.severity] > minLevel) continue;

    // Skip if context doesn't match
    if (expr.context !== 'any' && expr.context !== contextType) continue;

    const pattern = expr.isRegex && expr.regexPattern
      ? new RegExp(expr.regexPattern, 'g')
      : new RegExp(escapeRegex(expr.pattern), 'g');

    let m;
    while ((m = pattern.exec(content)) !== null) {
      const inDialogue = isInDialogue(m.index);

      // Skip narration patterns found in dialogue (may be intentional character voice)
      if (expr.context === 'narration' && inDialogue) continue;

      matches.push({
        expression: expr,
        category: expr.category,
        severity: expr.severity,
        position: m.index,
        matchedText: m[0],
        inDialogue,
      });
    }
  }

  // Sort by severity (critical first) then position
  return matches.sort((a, b) => {
    const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
    if (severityDiff !== 0) return severityDiff;
    return a.position - b.position;
  });
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Get suggested replacement for a match
 */
export function getSuggestedReplacement(match: BannedExpressionMatch): string {
  const replacements = match.expression.replacements.filter(r => r !== '');
  return replacements.length > 0 ? replacements[0] : '[삭제]';
}
```

Use TypeScript JSON import with assertion. Handle regex vs string patterns.
  </action>
  <verify>
    npm run build succeeds
    Files exist at src/korean/data/banned-expressions.json and src/korean/banned-expressions.ts
    JSON is valid and parseable
  </verify>
  <done>
    Banned expressions data file contains ~20 patterns in 5 categories
    Detection function respects context (narration vs dialogue)
    Severity filtering works correctly
    Matches sorted by severity then position
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate banned expression detection with Quality Oracle and Prose Surgeon</name>
  <files>
    src/pipeline/quality-oracle.ts
    src/pipeline/prose-surgeon.ts
  </files>
  <action>
**src/pipeline/quality-oracle.ts:**
1. Import banned expression detection:
   ```typescript
   import { detectBannedExpressions, getSuggestedReplacement, type BannedExpressionMatch } from '../korean/banned-expressions.js';
   ```

2. Extend options type for analyzeChapter:
   ```typescript
   options?: {
     honorificMatrix?: HonorificMatrix;
     dialogueAttributions?: Map<number, string>;
     detectBannedExpressions?: boolean;  // default true
     bannedExpressionMinSeverity?: 'critical' | 'high' | 'medium' | 'low';  // default 'medium'
   }
   ```

3. Add banned expression detection section in analyzeChapter (after filter word analysis, as related concern):
   ```typescript
   // 1b. Banned expression analysis (Korean AI-tell patterns)
   const bannedMatches = options?.detectBannedExpressions !== false
     ? detectBannedExpressions(content, 'narration', options?.bannedExpressionMinSeverity ?? 'medium')
     : [];

   // Create banned-expression directives (up to 2 critical/high, 1 medium)
   const criticalHighMatches = bannedMatches.filter(m => m.severity === 'critical' || m.severity === 'high');
   const mediumMatches = bannedMatches.filter(m => m.severity === 'medium');

   for (const match of criticalHighMatches.slice(0, 2)) {
     if (directives.length >= MAX_DIRECTIVES_PER_PASS) break;
     const paraIdx = findParagraphForPosition(paragraphs, match.position);
     const para = paragraphs[paraIdx];
     const replacement = getSuggestedReplacement(match);

     directives.push(createDirective(
       'banned-expression',
       1, // Highest priority for AI-tell
       {
         sceneNumber: Math.min(Math.ceil((paraIdx + 1) / Math.max(1, paragraphs.length / sceneCount)), sceneCount),
         paragraphStart: paraIdx,
         paragraphEnd: paraIdx,
       },
       `AI체 표현 "${match.matchedText}" 발견 (${match.category})`,
       para?.text || '',
       `"${match.matchedText}"를 "${replacement}"(으)로 대체하거나 문장을 자연스럽게 재구성하세요.`,
       1
     ));
   }

   for (const match of mediumMatches.slice(0, 1)) {
     if (directives.length >= MAX_DIRECTIVES_PER_PASS) break;
     // Similar directive creation with priority 3
   }
   ```

4. Add to QualityAssessment interface:
   ```typescript
   bannedExpressions?: {
     count: number;
     criticalCount: number;
     categories: string[];
   };
   ```

5. Include banned expressions in verdict calculation (critical expressions = REVISE).

**src/pipeline/prose-surgeon.ts:**
1. Add model routing for 'banned-expression':
   ```typescript
   'banned-expression': { model: 'sonnet', temperature: 0.4 },  // Mechanical replacement
   ```

2. Add scope limit:
   ```typescript
   'banned-expression': 1,  // Single paragraph
   ```
  </action>
  <verify>
    npm run build succeeds
    npm test passes
    analyzeChapter detects "한편," and produces banned-expression directive
  </verify>
  <done>
    Quality Oracle detects AI-tell patterns and generates directives
    Directives include replacement suggestions
    Critical/high severity expressions prioritized
    Prose Surgeon routes banned-expression to Sonnet with low temperature
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for banned expression detection</name>
  <files>
    tests/korean/banned-expressions.test.ts
  </files>
  <action>
Create test file `tests/korean/banned-expressions.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import {
  detectBannedExpressions,
  getSuggestedReplacement,
  BANNED_EXPRESSIONS,
  loadBannedExpressions,
} from '../../src/korean/banned-expressions.js';

describe('banned-expressions', () => {
  describe('BANNED_EXPRESSIONS', () => {
    it('loads expressions from JSON', () => {
      expect(BANNED_EXPRESSIONS.length).toBeGreaterThan(10);
    });

    it('includes critical AI-tell patterns', () => {
      const critical = BANNED_EXPRESSIONS.filter(e => e.severity === 'critical');
      expect(critical.length).toBeGreaterThan(0);
      expect(critical.some(e => e.pattern.includes('한편'))).toBe(true);
    });

    it('includes all severity levels', () => {
      const severities = new Set(BANNED_EXPRESSIONS.map(e => e.severity));
      expect(severities.has('critical')).toBe(true);
      expect(severities.has('high')).toBe(true);
      expect(severities.has('medium')).toBe(true);
    });
  });

  describe('detectBannedExpressions', () => {
    it('detects "한편," AI-tell pattern', () => {
      const content = '그는 문을 열었다. 한편, 그녀는 창가에 서 있었다.';
      const matches = detectBannedExpressions(content, 'narration', 'critical');
      expect(matches.length).toBeGreaterThan(0);
      expect(matches[0].matchedText).toBe('한편,');
      expect(matches[0].severity).toBe('critical');
    });

    it('detects "~하였다" archaic verb form', () => {
      const content = '그는 그녀에게 말하였다.';
      const matches = detectBannedExpressions(content, 'narration', 'critical');
      expect(matches.some(m => m.matchedText.includes('하였다'))).toBe(true);
    });

    it('detects translationese patterns', () => {
      const content = '이것은 한국 문화에 있어서 중요한 요소다.';
      const matches = detectBannedExpressions(content, 'narration', 'high');
      expect(matches.some(m => m.matchedText.includes('에 있어서'))).toBe(true);
    });

    it('skips narration patterns inside dialogue', () => {
      const content = '"한편, 나는 그렇게 생각해." 그녀가 말했다.';
      const matches = detectBannedExpressions(content, 'narration', 'critical');
      // "한편," is in dialogue, should be skipped for narration context
      expect(matches.filter(m => m.matchedText === '한편,').length).toBe(0);
    });

    it('respects minimum severity filter', () => {
      const content = '한편, 그녀는 , 그리고 기다렸다.';
      const criticalOnly = detectBannedExpressions(content, 'narration', 'critical');
      const allSeverities = detectBannedExpressions(content, 'narration', 'low');
      expect(allSeverities.length).toBeGreaterThanOrEqual(criticalOnly.length);
    });

    it('sorts results by severity then position', () => {
      const content = ', 그리고 한편, 다음으로';
      const matches = detectBannedExpressions(content, 'narration', 'medium');
      if (matches.length >= 2) {
        // Critical (한편,) should come before medium (, 그리고)
        const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
        expect(severityOrder[matches[0].severity]).toBeLessThanOrEqual(severityOrder[matches[1].severity]);
      }
    });
  });

  describe('getSuggestedReplacement', () => {
    it('returns first non-empty replacement', () => {
      const match = {
        expression: { pattern: '한편,', replacements: ['', '그때', '그런데'], context: 'narration' as const },
        category: 'ai-tell' as const,
        severity: 'critical' as const,
        position: 0,
        matchedText: '한편,',
        inDialogue: false,
      };
      expect(getSuggestedReplacement(match)).toBe('그때');
    });

    it('returns [삭제] when all replacements are empty', () => {
      const match = {
        expression: { pattern: '한편,', replacements: ['', ''], context: 'narration' as const },
        category: 'ai-tell' as const,
        severity: 'critical' as const,
        position: 0,
        matchedText: '한편,',
        inDialogue: false,
      };
      expect(getSuggestedReplacement(match)).toBe('[삭제]');
    });
  });
});
```
  </action>
  <verify>
    npm test -- tests/korean/banned-expressions.test.ts passes
    All pattern detection tests pass
    Context and severity filtering verified
  </verify>
  <done>
    Test file exists with comprehensive coverage
    All tests pass
    Dialogue exclusion logic verified
    Severity sorting verified
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm test` passes all existing and new tests
3. Quality Oracle detects AI-tell patterns in sample text
4. Directives include Korean replacement suggestions
5. Prose Surgeon MODEL_ROUTING includes 'banned-expression'
</verification>

<success_criteria>
- Banned expressions JSON contains ~20 patterns in 5 severity categories
- Detection respects narration vs dialogue context
- Critical AI-tell (한편, 그러나, ~하였다) detected with highest priority
- Quality Oracle generates 'banned-expression' surgical directives
- Replacements suggested in directive instructions
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-korean-specialization/03-02-SUMMARY.md`
</output>
