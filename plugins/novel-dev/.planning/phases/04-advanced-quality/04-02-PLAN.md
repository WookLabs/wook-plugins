---
phase: "04-advanced-quality"
plan: "02"
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - "src/style-library/types.ts"
  - "src/style-library/style-analyzer.ts"
  - "src/style-library/style-profile.ts"
  - "src/quality/types.ts"
  - "src/quality/stage-evaluators.ts"
  - "schemas/style-profile.schema.json"
  - "tests/style-library/style-analyzer.test.ts"
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can provide reference text and system extracts quantifiable style patterns"
    - "Sentence length distribution is computed (mean, stddev, p25/p50/p75)"
    - "Vocabulary complexity is measured (TTR, MTLD, unique words per 1000)"
    - "Dialogue ratio and sensory density are computed"
    - "Style constraints can be generated as prompt text for generation"
    - "Subsequent prose generation reflects extracted style patterns via StyleStageEvaluator"
  artifacts:
    - path: "src/style-library/types.ts"
      provides: "StyleProfile, StyleMetrics interfaces"
      contains: "interface StyleProfile"
    - path: "src/style-library/style-analyzer.ts"
      provides: "Reference text style extraction"
      exports: ["analyzeStyleFromReference", "computeSentenceLengthStats", "computeVocabularyMetrics"]
    - path: "src/style-library/style-profile.ts"
      provides: "Style matching and constraint generation"
      exports: ["buildStyleConstraints", "computeStyleMatch"]
    - path: "src/quality/types.ts"
      provides: "MultiStageOptions with styleProfile field"
      contains: "styleProfile?: StyleProfile"
    - path: "src/quality/stage-evaluators.ts"
      provides: "StyleStageEvaluator with style matching integration"
      contains: "computeStyleMatch"
    - path: "schemas/style-profile.schema.json"
      provides: "JSON Schema for StyleProfile validation"
      contains: "sentenceLength"
  key_links:
    - from: "src/style-library/style-analyzer.ts"
      to: "src/style-library/types.ts"
      via: "StyleProfile import"
      pattern: "import.*StyleProfile.*from.*types"
    - from: "src/style-library/style-profile.ts"
      to: "src/style-library/types.ts"
      via: "StyleProfile and StyleMetrics import"
      pattern: "import.*StyleProfile.*from.*types"
    - from: "src/quality/stage-evaluators.ts"
      to: "src/style-library/style-profile.ts"
      via: "computeStyleMatch import for style evaluation"
      pattern: "import.*computeStyleMatch.*from.*style-profile"
    - from: "src/quality/stage-evaluators.ts"
      to: "src/quality/types.ts"
      via: "MultiStageOptions with styleProfile"
      pattern: "options\\.styleProfile"
---

<objective>
Implement reference style learning that extracts quantifiable patterns from author samples using stylometric metrics, AND integrate style matching into the multi-stage revision pipeline.

Purpose: Users can provide a reference novel/author and the system extracts measurable style patterns (sentence length, vocabulary complexity, dialogue ratio) that guide subsequent prose generation toward the reference style. The StyleStageEvaluator uses these patterns to generate style-alignment directives.

Output: Style analysis module with StyleProfile schema, metric computation functions, constraint generation for prose prompts, and integration with StyleStageEvaluator for closed-loop style enforcement.
</objective>

<execution_context>
@C:\Users\jodnr\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jodnr\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-advanced-quality/04-RESEARCH.md

# Existing style library to extend
@src/style-library/types.ts
@src/style-library/storage.ts
@src/style-library/retrieval.ts
@src/pipeline/quality-oracle.ts

# Plan 04-01 artifacts (required for Task 4)
@src/quality/types.ts
@src/quality/stage-evaluators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend style library types with StyleProfile and create JSON schema</name>
  <files>
    src/style-library/types.ts
    schemas/style-profile.schema.json
  </files>
  <action>
**Extend src/style-library/types.ts:**
Add new interfaces after existing types:

```typescript
/**
 * Style profile extracted from reference text
 */
export interface StyleProfile {
  id: string;                          // "style_author_work"
  source: {
    author: string;
    work?: string;
    sampleSize: number;                // chars analyzed
    sampleCount: number;               // number of excerpts
  };
  metrics: StyleMetrics;
  qualitativeNotes?: string[];         // e.g., "short punchy dialogue"
  created_at: string;
}

export interface StyleMetrics {
  sentenceLength: {
    mean: number;                      // Average in characters
    stddev: number;
    p25: number;                       // 25th percentile
    p50: number;                       // Median
    p75: number;                       // 75th percentile
  };
  vocabulary: {
    ttr: number;                       // Type-Token Ratio (0-1)
    mtld: number;                      // Measure of Textual Lexical Diversity
    uniqueWordsPerThousand: number;    // Normalized unique count
  };
  dialogueRatio: number;               // 0-1 (55-65% typical)
  sensoryDensity: number;              // senses per 1000 chars
  punctuationPattern: {
    commasPerSentence: number;
    exclamationRate: number;           // per 1000 chars
    questionRate: number;              // per 1000 chars
  };
  paragraphLength: {
    mean: number;                      // chars
    variance: number;
  };
}

export interface StyleMatchOptions {
  referenceProfile?: StyleProfile;
  tolerances?: {
    sentenceLengthVariance: number;    // default: 0.3
    vocabularyComplexity: number;      // default: 0.1
    dialogueRatioTolerance: number;    // default: 0.1
  };
}
```

**Create schemas/style-profile.schema.json:**
JSON Schema that validates StyleProfile objects with:
- Required: id, source (author, sampleSize, sampleCount), metrics, created_at
- Metrics object with all sub-properties
- Appropriate number ranges (ttr: 0-1, percentiles > 0, etc.)
  </action>
  <verify>
npx tsc --noEmit
node -e "const s = require('./schemas/style-profile.schema.json'); console.log('Schema properties:', Object.keys(s.properties));"
  </verify>
  <done>
- StyleProfile, StyleMetrics, StyleMatchOptions interfaces added to types.ts
- schemas/style-profile.schema.json exists and validates correctly
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create style analyzer with Korean-aware metric computation</name>
  <files>
    src/style-library/style-analyzer.ts
  </files>
  <action>
Create style-analyzer.ts with Korean-text-aware metric computation:

**computeSentenceLengthStats(content: string):**
- Split by Korean sentence endings: `.`, `!`, `?`, `。`, `!`, `?`
- Filter empty strings
- Compute mean, stddev, p25, p50, p75 of character lengths
- Handle edge case of no sentences gracefully

**computeVocabularyMetrics(content: string):**
- Extract Korean words using regex: /[가-힣]+/g
- Compute TTR: unique_words / total_words
- Compute MTLD (Measure of Textual Lexical Diversity):
  - Use FACTOR_THRESHOLD = 0.72
  - Count factors where TTR drops below threshold
  - MTLD = total_words / factors
- Compute uniqueWordsPerThousand: (unique / content.length) * 1000

**computeDialogueRatio(content: string):**
- Match Korean dialogue markers: "", "", ``
- Sum dialogue character lengths
- Return dialogueChars / total length

**computeSensoryDensity(content: string):**
- Reuse SENSORY_CATEGORIES from quality-oracle.ts
- Count sensory word occurrences
- Return count / content.length * 1000

**computePunctuationPattern(content: string):**
- Count commas, exclamations, questions
- Compute per-sentence and per-1000-char rates

**computeParagraphStats(content: string):**
- Split by double newlines
- Compute mean and variance of paragraph lengths

**Main function: analyzeStyleFromReference(samples: string[], sourceInfo: {author, work?}): StyleProfile**
- Combine samples
- Run all metric computations
- Return complete StyleProfile with generated ID and timestamp
  </action>
  <verify>
npx tsc --noEmit
node -e "const a = require('./src/style-library/style-analyzer.js'); const s = a.analyzeStyleFromReference(['테스트 문장입니다. 또 다른 문장.'], {author: 'test'}); console.log('Profile:', s.id, s.metrics.sentenceLength.mean);"
  </verify>
  <done>
- style-analyzer.ts exports all metric computation functions
- analyzeStyleFromReference generates complete StyleProfile from samples
- Korean text handling works correctly (sentence splitting, word extraction)
- MTLD computation follows standard algorithm
  </done>
</task>

<task type="auto">
  <name>Task 3: Create style profile matching and constraint generation with tests</name>
  <files>
    src/style-library/style-profile.ts
    src/style-library/index.ts
    tests/style-library/style-analyzer.test.ts
  </files>
  <action>
**style-profile.ts:**

**buildStyleConstraints(profile: StyleProfile): string**
Generate prompt-ready constraint text:
```
## Style Constraints (Reference: {author})

### Sentence Structure
- Target sentence length: {mean} chars (range: {p25}-{p75})
- Standard deviation target: {stddev}

### Vocabulary
- Lexical diversity (TTR): {ttr * 100}%
- Aim for {uniqueWordsPerThousand} unique words per 1000 chars
- Vocabulary sophistication: {High|Medium|Accessible based on mtld}

### Dialogue Balance
- Target dialogue ratio: {dialogueRatio * 100}%
- {Dialogue-heavy|Narration-focused|Balanced} style

### Sensory Richness
- Target: {sensoryDensity} sensory details per 1000 chars
```

**computeStyleMatch(content: string, profile: StyleProfile, tolerances?: StyleMatchOptions['tolerances']): number**
- Compute metrics for content
- Compare each metric to profile with tolerances
- Return 0-100 score based on how closely content matches profile
- Weight: sentence length 30%, vocabulary 25%, dialogue 20%, sensory 15%, other 10%

**Update src/style-library/index.ts:**
- Export all new functions from style-analyzer.ts and style-profile.ts

**tests/style-library/style-analyzer.test.ts:**
- Test computeSentenceLengthStats with known Korean text
- Test computeVocabularyMetrics TTR calculation
- Test computeMTLD returns reasonable values (40-120 typical)
- Test computeDialogueRatio with dialogue-heavy and narration-heavy samples
- Test analyzeStyleFromReference generates valid profile
- Test buildStyleConstraints produces readable prompt text
- Test computeStyleMatch scores similar texts higher than different texts
- Test Korean sentence splitting handles various endings
- Test edge cases: empty string, single sentence, no dialogue
  </action>
  <verify>
npx tsc --noEmit
npm test -- tests/style-library/style-analyzer.test.ts
  </verify>
  <done>
- style-profile.ts exports buildStyleConstraints and computeStyleMatch
- Style library index exports all new analysis functions
- Tests cover metric computation accuracy
- Korean text edge cases handled
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate style matching into StyleStageEvaluator and MultiStageOptions</name>
  <files>
    src/quality/types.ts
    src/quality/stage-evaluators.ts
  </files>
  <action>
**Extend src/quality/types.ts:**
Import StyleProfile from style-library and add to MultiStageOptions:

```typescript
import { StyleProfile } from '../style-library/types.js';

// In MultiStageOptions interface (should already exist from 04-01):
export interface MultiStageOptions extends AnalyzeChapterOptions {
  scenes?: SceneContext[];
  styleProfile?: StyleProfile;  // ADD THIS FIELD
  subtextAnnotations?: SubtextAnnotation[];
  voiceProfiles?: VoiceProfile[];
}
```

**Modify src/quality/stage-evaluators.ts:**

1. Add import at top:
```typescript
import { computeStyleMatch, buildStyleConstraints } from '../style-library/style-profile.js';
import { StyleProfile } from '../style-library/types.js';
```

2. Extend StyleStageEvaluator.generateDirectives() method:
```typescript
// In StyleStageEvaluator class:
async generateDirectives(content: string, options?: MultiStageOptions): Promise<SurgicalDirective[]> {
  const directives: SurgicalDirective[] = [];

  // Existing prose quality directives (filter-word, sensory, rhythm, etc.)
  const proseDirectives = await this.generateProseDirectives(content, options);
  directives.push(...proseDirectives);

  // NEW: Style alignment directives when reference profile provided
  if (options?.styleProfile) {
    const styleScore = computeStyleMatch(content, options.styleProfile);

    // If style match is below threshold (70), generate alignment directives
    if (styleScore < 70) {
      const styleConstraints = buildStyleConstraints(options.styleProfile);
      const styleDirective: SurgicalDirective = {
        type: 'style-alignment',
        severity: styleScore < 50 ? 'high' : 'medium',
        location: { startParagraph: 0, endParagraph: -1 }, // Full scope
        currentText: content.slice(0, 500) + '...', // Sample
        issue: `Style match score: ${styleScore}/100. Prose deviates from reference style.`,
        suggestion: `Align prose to reference style:\n${styleConstraints}`,
        confidence: 0.8
      };
      directives.push(styleDirective);
    }
  }

  return directives;
}

// Update score() to factor in style match when profile provided:
async score(content: string, options?: MultiStageOptions): Promise<number> {
  // Existing prose quality score
  const proseScore = await this.computeProseScore(content, options);

  // If no style profile, return prose score only
  if (!options?.styleProfile) {
    return proseScore;
  }

  // Blend: 70% prose quality + 30% style alignment
  const styleScore = computeStyleMatch(content, options.styleProfile);
  return Math.round(proseScore * 0.7 + styleScore * 0.3);
}
```

**Key integration points:**
- StyleStageEvaluator now checks for options.styleProfile
- computeStyleMatch is called to measure how well content matches reference
- style-alignment directives are generated when match < 70
- Overall score blends prose quality (70%) with style alignment (30%)

**Export updates:**
Ensure style-profile.ts functions are exported through style-library/index.ts (done in Task 3).
  </action>
  <verify>
npx tsc --noEmit
node -e "
const { StyleStageEvaluator } = require('./src/quality/stage-evaluators.js');
const { analyzeStyleFromReference } = require('./src/style-library/style-analyzer.js');

// Create a test profile
const profile = analyzeStyleFromReference(['짧은 문장. 또 짧은 문장.'], { author: 'test' });

// Test that evaluator accepts styleProfile
const evaluator = new StyleStageEvaluator();
console.log('StyleStageEvaluator created:', !!evaluator);
console.log('Has generateDirectives:', typeof evaluator.generateDirectives === 'function');
"
  </verify>
  <done>
- MultiStageOptions.styleProfile field added to src/quality/types.ts
- StyleStageEvaluator imports computeStyleMatch and buildStyleConstraints
- generateDirectives() generates 'style-alignment' directives when styleProfile provided and match < 70
- score() blends prose quality (70%) with style alignment (30%) when profile provided
- TypeScript compiles without errors
- Integration tested with sample profile
  </done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation
npx tsc --noEmit

# Run style library tests
npm test -- tests/style-library/

# Verify style analysis works
node -e "
const { analyzeStyleFromReference, buildStyleConstraints, computeStyleMatch } = require('./src/style-library/index.js');
const sample = '그녀는 조용히 문을 열었다. 창밖으로 비가 내리고 있었다. \"정말 오래됐네.\" 그가 속삭였다.';
const profile = analyzeStyleFromReference([sample], { author: '테스트 작가' });
console.log('Profile ID:', profile.id);
console.log('Sentence mean:', profile.metrics.sentenceLength.mean.toFixed(1));
console.log('Dialogue ratio:', (profile.metrics.dialogueRatio * 100).toFixed(1) + '%');
console.log('Constraints preview:', buildStyleConstraints(profile).slice(0, 200));
"

# Verify integration with StyleStageEvaluator
node -e "
const { StyleStageEvaluator } = require('./src/quality/stage-evaluators.js');
const { analyzeStyleFromReference, computeStyleMatch } = require('./src/style-library/index.js');

const refSample = '짧은 문장이다. 간결하게. 핵심만.';
const profile = analyzeStyleFromReference([refSample], { author: '간결체 작가' });

const longProse = '이것은 매우 길고 장황하며 끝없이 이어지는 문장으로 간결한 스타일과는 전혀 맞지 않는 산문입니다.';
const matchScore = computeStyleMatch(longProse, profile);
console.log('Style match (should be low):', matchScore);

const shortProse = '짧게 썼다. 간단하게. 이렇게.';
const goodMatch = computeStyleMatch(shortProse, profile);
console.log('Style match (should be higher):', goodMatch);
"
```
</verification>

<success_criteria>
1. StyleProfile interface captures all stylometric metrics from RESEARCH.md
2. JSON Schema validates StyleProfile objects
3. analyzeStyleFromReference extracts metrics from Korean text correctly
4. TTR and MTLD computed using standard formulas
5. Korean sentence splitting handles `.`, `!`, `?`, `。` endings
6. buildStyleConstraints generates readable prompt text
7. computeStyleMatch returns 0-100 similarity score
8. MultiStageOptions includes optional styleProfile field
9. StyleStageEvaluator.generateDirectives() produces 'style-alignment' directives when profile provided
10. StyleStageEvaluator.score() blends prose quality with style alignment
11. All tests pass (18+ test cases expected)
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-quality/04-02-SUMMARY.md`
</output>
