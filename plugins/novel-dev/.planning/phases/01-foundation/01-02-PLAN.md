---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01", "01-03"]
files_modified:
  - schemas/context-bundle.schema.json
  - src/context/types.ts
  - src/context/tiers.ts
  - src/context/priorities.ts
  - src/context/index.ts
  - tests/context/tiers.test.ts
autonomous: true

must_haves:
  truths:
    - "Writing agents receive a tiered context bundle (hot/warm/cold) instead of a flat priority dump"
    - "Hot tier contains current scene plan, 2-3 style exemplars, full character profiles, and emotional directives within 15K tokens"
    - "Warm tier contains 5-chapter sliding window summaries, active foreshadowing, and relationship states within 25K tokens"
    - "Style exemplars are positioned at both beginning AND end of context (sandwich pattern)"
    - "Character profiles are NEVER compressed — all scene characters get full ~2000 tokens regardless of budget pressure"
  artifacts:
    - path: "schemas/context-bundle.schema.json"
      provides: "JSON Schema for tiered context bundle output"
      contains: "hot"
    - path: "src/context/tiers.ts"
      provides: "Tiered context assembly engine"
      exports: ["assembleTieredContext", "assignTier", "TieredContextBundle", "TierBudget", "DEFAULT_TIER_BUDGET"]
    - path: "src/context/types.ts"
      provides: "Extended ContextType with v5 types"
      contains: "exemplar"
    - path: "src/context/priorities.ts"
      provides: "Extended priority calculation for new context types"
      contains: "exemplar"
  key_links:
    - from: "src/context/tiers.ts"
      to: "src/context/priorities.ts"
      via: "getPriority call for item sorting within tiers"
      pattern: "getPriority"
    - from: "src/context/tiers.ts"
      to: "src/context/estimator.ts"
      via: "estimateTokens for budget tracking"
      pattern: "estimateTokens"
    - from: "src/context/tiers.ts"
      to: "src/style-library/retrieval.ts"
      via: "queryExemplars to fetch matched exemplars for hot tier"
      pattern: "queryExemplars"
    - from: "src/context/tiers.ts"
      to: "src/scene/types.ts"
      via: "SceneV5 type for scene plan context"
      pattern: "SceneV5"
---

<objective>
Build the Context Manager tiered assembly system: extend the existing context module with hot/warm/cold tier assignment, token budgets per tier, and the sandwich pattern for exemplar placement.

Purpose: The current context system dumps everything into a flat 80K priority queue. This plan creates a structured tiered system where hot context (scene plan, exemplars, character profiles) gets maximum attention, warm context (5-chapter window, foreshadowing) provides continuity, and cold context (world, plot structure) serves as reference. The sandwich pattern places exemplars at both beginning and end of the prompt to counter "lost in the middle" attention degradation.

Output: Extended context types, tier assignment logic, tiered assembly function, budget enforcement, and tests.
</objective>

<execution_context>
@C:\Users\jodnr\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jodnr\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md

Prior plan outputs (needed for types):
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

Key existing files:
@src/context/types.ts
@src/context/priorities.ts
@src/context/estimator.ts
@src/context/loader.ts
@src/context/overflow-handler.ts
@src/context/index.ts
@src/context/config.ts
@src/types.ts
@src/style-library/types.ts
@src/scene/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend context types and priorities for v5 context types</name>
  <files>
    src/context/types.ts
    src/context/priorities.ts
    schemas/context-bundle.schema.json
  </files>
  <action>
1. Modify `src/context/types.ts`:
   - Extend `ContextType` union with new v5 types:
     * 'exemplar' -- style exemplars (hot tier)
     * 'scene_plan' -- current scene plan (hot tier)
     * 'emotional_directive' -- emotional arc directives (hot tier)
     * 'relationship_state' -- active relationship dynamics (warm tier)
   - Add new types:
     * `ContextTier = 'hot' | 'warm' | 'cold'`
     * `TierBudget = { hot: number, warm: number, cold: number }`
     * `TieredContextBundle = { hot: ContextItem[], warm: ContextItem[], cold: ContextItem[], totalTokens: number, tierBreakdown: Record<ContextTier, number>, sandwichSplit: { hotPrefix: ContextItem[], hotSuffix: ContextItem[] } }`
     * The `sandwichSplit` field separates hot tier items into prefix (scene plan, exemplar 1) and suffix (exemplar 2-3, emotional directives) for sandwich placement
   - Add to `ItemMetadata`:
     * `appearsInCurrentScene?: boolean` (more specific than existing appearsInCurrentChapter)
     * `isActive?: boolean` (for foreshadowing warm tier check)
     * `isPovCharacter?: boolean` (for character budget priority)
   - Add `DEFAULT_TIER_BUDGET` constant: `{ hot: 15000, warm: 25000, cold: 40000 }`
   - Keep ALL existing types unchanged. Only ADD new ones.

2. Modify `src/context/priorities.ts`:
   - Add new entries to `basePriority` Record for the 4 new ContextTypes:
     * exemplar: 10 (highest -- research shows exemplars are dominant quality factor)
     * scene_plan: 10 (always required in hot tier)
     * emotional_directive: 8
     * relationship_state: 6
   - Add new entries to `requiredByType` Record:
     * exemplar: true
     * scene_plan: true
     * emotional_directive: false
     * relationship_state: false
   - Extend `getPriority` function with priority logic for new types:
     * exemplar: always 10 (no dynamic adjustment needed)
     * scene_plan: always 10
     * emotional_directive: 9 if scene has emotional_arc defined, else 6
     * relationship_state: 8 if characters have evolving relationship in current chapter, else 5
   - Extend `isRequired` function for new types:
     * scene_plan: always required
     * exemplar: required (at least 1 exemplar must be present)
   - Keep ALL existing priority logic unchanged. Only ADD new cases.

3. Create `schemas/context-bundle.schema.json` (JSON Schema draft-07):
   - Describes the output shape of tiered context assembly
   - Properties: hot (array of context items), warm (array), cold (array), totalTokens (integer), tierBreakdown (object with hot/warm/cold integer properties)
   - Follow existing schema conventions
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run validate:schemas` passes
    - `npx vitest run tests/context/priorities.test.ts` -- existing tests still pass (no regression)
  </verify>
  <done>
    - ContextType extended with exemplar, scene_plan, emotional_directive, relationship_state
    - TieredContextBundle type defined with sandwichSplit for exemplar positioning
    - Priority calculations handle all 4 new context types
    - Existing context tests still pass (no regression)
  </done>
</task>

<task type="auto">
  <name>Task 2: Tiered assembly engine with sandwich pattern and tests</name>
  <files>
    src/context/tiers.ts
    src/context/index.ts
    tests/context/tiers.test.ts
  </files>
  <action>
1. Create `src/context/tiers.ts`:

   Import from existing modules: ContextItem, ContextType, ContextTier, TierBudget, TieredContextBundle, ItemMetadata, DEFAULT_TIER_BUDGET from './types.js'; getPriority from './priorities.js'; estimateTokens from './estimator.js'

   Functions to implement:

   a. `assignTier(type: ContextType, metadata: ItemMetadata): ContextTier`
      - Hot tier: 'exemplar', 'scene_plan', 'emotional_directive', and 'character' when metadata.appearsInCurrentScene is true
      - Warm tier: 'summary' (within 5-chapter window), 'relationship_state', 'foreshadowing' when metadata.isActive, 'plot'
      - Cold tier: everything else ('world', 'act_summary', distant 'summary', inactive 'foreshadowing', non-scene 'character')
      - 'style' (existing type for style-guide.json) goes to warm tier

   b. `assembleTieredContext(items: ContextItem[], metadata: ItemMetadata, budget?: Partial<TierBudget>): TieredContextBundle`
      - Merge budget with DEFAULT_TIER_BUDGET
      - For each item: assign tier via assignTier, calculate priority via getPriority
      - Sort items within each tier by priority descending
      - Apply budget enforcement per tier:
        * Hot tier overflow strategy (LOCKED DECISION: characters are NEVER compressed):
          1. All scene characters ALWAYS keep full ~2000 tokens — no compression, no excerpts, no reduction
          2. Exemplars and scene_plan are NEVER dropped
          3. If hot tier exceeds 15K, drop lowest-priority non-essential hot items in this order:
             a. emotional_directive items (drop lowest-priority first)
             b. relationship_state items that were promoted to hot
             c. If STILL over budget after dropping all droppable items, log a warning but keep all characters and exemplars intact (allow slight budget overshoot rather than compress characters)
          4. NEVER compress, excerpt, or reduce character profiles under any circumstances
        * Warm tier: If over 25K tokens, drop lowest-priority items. Summaries outside the 5-chapter window drop first.
        * Cold tier: If over 40K tokens, drop lowest-priority items freely.
      - Build sandwichSplit from hot tier:
        * hotPrefix: scene_plan (always first) + first exemplar (1 good exemplar)
        * hotSuffix: remaining exemplars (1-2 good + 0-1 anti) + emotional_directive + character profiles
        * This positions exemplars at BOTH beginning and end, with generation instruction between suffix and the actual generation
      - Calculate totalTokens and tierBreakdown

   c. `formatPromptOrder(bundle: TieredContextBundle): ContextItem[]`
      - Returns items in the prompt assembly order:
        1. bundle.sandwichSplit.hotPrefix (scene plan + exemplar 1)
        2. bundle.cold (reference material)
        3. bundle.warm (narrative continuity)
        4. bundle.sandwichSplit.hotSuffix (exemplars 2-3 + characters + emotional directive)
      - This is the order for prompt construction. The actual prompt builder (Phase 2) will use this.

   d. `getTierStats(bundle: TieredContextBundle): string`
      - Returns a human-readable summary: "Hot: X/15000 tokens (N items) | Warm: X/25000 (N items) | Cold: X/40000 (N items) | Total: X/80000"

2. Update `src/context/index.ts`:
   - Add exports from tiers.ts: assembleTieredContext, assignTier, formatPromptOrder, getTierStats
   - Keep all existing exports unchanged

3. Create `tests/context/tiers.test.ts` (Vitest):

   Test cases for assignTier:
   - 'exemplar' -> 'hot'
   - 'scene_plan' -> 'hot'
   - 'character' with appearsInCurrentScene: true -> 'hot'
   - 'character' with appearsInCurrentScene: false -> 'cold'
   - 'summary' -> 'warm'
   - 'foreshadowing' with isActive: true -> 'warm'
   - 'foreshadowing' with isActive: false -> 'cold'
   - 'world' -> 'cold'
   - 'act_summary' -> 'cold'

   Test cases for assembleTieredContext:
   - **Basic assembly**: Given mix of items, produces correct tier assignment with token breakdown
   - **Budget enforcement — no character compression**: When hot tier exceeds 15K with many characters, emotional_directives are dropped first but ALL character profiles remain at full ~2000 tokens
   - **POV and non-POV characters both uncompressed**: Both POV and non-POV scene characters keep full ~2000 tokens even when budget is tight
   - **Characters never compressed even when budget is tight**: Create test with 6+ scene characters (~12K tokens just for characters) plus exemplars and scene_plan. Verify NO character is compressed or excerpted. Instead, emotional_directives and relationship_states are dropped. If budget still exceeded, all characters remain (slight overshoot allowed).
   - **Sandwich split**: hotPrefix contains scene_plan + 1 exemplar; hotSuffix contains remaining exemplars + character profiles
   - **Warm window**: Only summaries within 5 chapters of current are in warm tier
   - **Cold overflow**: Items exceeding cold budget are dropped by lowest priority

   Test cases for formatPromptOrder:
   - **Order verification**: hotPrefix items come first, then cold, then warm, then hotSuffix
   - **Exemplar sandwich**: At least one exemplar appears in prefix AND at least one in suffix

   Create test fixtures:
   - Mock ContextItems for each type (exemplar, scene_plan, character, summary, world, etc.)
   - Use realistic token estimates (exemplar ~1500, character ~2000, summary ~1000, world ~3000)
  </action>
  <verify>
    - `npx vitest run tests/context/` -- ALL context tests pass (both existing and new)
    - `npx tsc --noEmit` passes
    - No regression in existing estimator.test.ts or priorities.test.ts
  </verify>
  <done>
    - assembleTieredContext produces hot/warm/cold bundles from flat item list
    - Hot tier budget enforced by dropping emotional directives and relationship states — NEVER by compressing characters
    - All scene characters (POV and non-POV) always get full ~2000 tokens with no compression
    - Sandwich pattern: exemplars appear in both hotPrefix and hotSuffix
    - formatPromptOrder returns items in correct prompt assembly sequence
    - 5-chapter sliding window enforced for warm tier summaries
    - All existing + new tests pass
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run validate:schemas` passes
3. `npx vitest run tests/context/` -- all context tests pass (estimator + priorities + tiers)
4. No existing test regression (priorities.test.ts, estimator.test.ts still pass)
5. Tiered assembly respects budgets: hot <= 15K (with slight overshoot allowed to preserve characters), warm <= 25K, cold <= 40K
</verification>

<success_criteria>
- Context items are assigned to hot/warm/cold tiers by type and metadata
- Hot tier targets 15K budget by dropping emotional directives and relationship states when over budget
- Character profiles are NEVER compressed, excerpted, or reduced — all scene characters get full ~2000 tokens always
- Warm tier enforces 5-chapter sliding window within 25K budget
- Cold tier holds reference material within 40K budget
- Sandwich pattern places exemplars at both beginning (prefix) and end (suffix) of prompt
- formatPromptOrder returns items in the correct prompt assembly sequence
- All existing context tests still pass (no regression)
- All new tier tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
