---
phase: 02-core-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pipeline/types.ts
  - src/pipeline/scene-writer.ts
  - src/pipeline/assembler.ts
  - src/pipeline/index.ts
  - schemas/surgical-directive.schema.json
  - tests/pipeline/scene-writer.test.ts
autonomous: true

must_haves:
  truths:
    - "Chapter can be decomposed into scenes, each drafted individually"
    - "Drafted scenes are assembled with smooth transitions"
    - "Each scene draft uses fresh exemplar injection from Style Library"
    - "Scene writer respects 800-1500 char scene target"
  artifacts:
    - path: "src/pipeline/types.ts"
      provides: "SurgicalDirective, DirectiveType, SceneDraftResult, QualityOracleResult types"
      exports: ["SurgicalDirective", "DirectiveType", "PassageLocation", "SceneDraftResult", "SceneWriterConfig", "QualityOracleResult"]
    - path: "src/pipeline/scene-writer.ts"
      provides: "Scene-by-scene drafting orchestration with exemplar injection"
      exports: ["draftScene", "writeChapterByScenes"]
    - path: "src/pipeline/assembler.ts"
      provides: "Scene assembly with transition detection and smoothing"
      exports: ["assembleScenes", "detectTransitionGaps", "AssemblyResult"]
    - path: "schemas/surgical-directive.schema.json"
      provides: "JSON Schema for directive validation"
      contains: "SurgicalDirective"
  key_links:
    - from: "src/pipeline/scene-writer.ts"
      to: "src/style-library/retrieval.ts"
      via: "queryExemplars import"
      pattern: "import.*queryExemplars.*from.*style-library"
    - from: "src/pipeline/scene-writer.ts"
      to: "src/context/tiers.ts"
      via: "assembleTieredContext import"
      pattern: "import.*assembleTieredContext.*from.*context"
    - from: "src/pipeline/scene-writer.ts"
      to: "src/scene/types.ts"
      via: "SceneV5 type import"
      pattern: "import.*SceneV5.*from.*scene"
---

<objective>
Create the scene-based writing pipeline infrastructure: TypeScript types for the directive system, scene writer orchestration that drafts each scene with fresh exemplar injection using Phase 1's Style Library and Context Manager, and an assembler that combines scenes with transition smoothing.

Purpose: Enable the architectural shift from monolithic chapter writing to decomposed scene-by-scene composition, which research shows yields 40%+ quality improvement through focused attention and fresh exemplar injection per scene.

Output: Pipeline module with types, scene writer, and assembler ready for Quality Oracle integration in Plan 02.
</objective>

<execution_context>
@C:\Users\jodnr\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jodnr\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-pipeline/02-RESEARCH.md

# Phase 1 Infrastructure (dependencies)
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

# Source references
@src/style-library/types.ts
@src/style-library/retrieval.ts
@src/context/tiers.ts
@src/context/types.ts
@src/scene/types.ts
@src/scene/decomposer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pipeline types and surgical directive schema</name>
  <files>
    - src/pipeline/types.ts
    - schemas/surgical-directive.schema.json
  </files>
  <action>
Create the pipeline module type system and directive schema:

**src/pipeline/types.ts:**
```typescript
// Directive types for Quality Oracle -> Prose Surgeon communication
export type DirectiveType =
  | 'show-not-tell'       // Emotional telling -> physical showing
  | 'filter-word-removal' // Remove filter words (느꼈다, 보였다, 생각했다)
  | 'sensory-enrichment'  // Add missing senses (2+ per 500 chars required)
  | 'rhythm-variation'    // Fix monotonous sentence structure
  | 'dialogue-subtext'    // On-the-nose dialogue -> subtext
  | 'cliche-replacement'  // Replace stock Korean AI phrases
  | 'transition-smoothing'// Abrupt scene transition
  | 'voice-consistency'   // Character voice drift
  | 'proofreading';       // Grammar, spacing, punctuation

export interface PassageLocation {
  sceneNumber: number;
  paragraphStart: number;
  paragraphEnd: number;
  characterOffset?: number;
}

export interface SurgicalDirective {
  id: string;                       // Pattern: dir_{type}_{NNN}
  type: DirectiveType;
  priority: number;                 // 1 (highest) to 10
  location: PassageLocation;
  issue: string;                    // Specific problem
  currentText: string;              // Problematic passage
  instruction: string;              // Concrete fix instruction
  exemplarId?: string;              // Reference exemplar ID
  exemplarContent?: string;         // Actual exemplar text
  maxScope: number;                 // Max paragraphs to touch (1-5)
}

// Scene writer types
export interface SceneWriterConfig {
  maxExemplarsPerScene: number;     // Default: 3 (2 good + 1 anti)
  includeAntiExemplar: boolean;     // Default: true
  chainOfThoughtEnabled: boolean;   // Default: true
  targetSceneLength: { min: number; max: number }; // Default: 800-1500 chars
}

export interface SceneDraftResult {
  sceneNumber: number;
  content: string;
  estimatedTokens: number;
  exemplarsUsed: string[];          // Exemplar IDs for tracking
  preWritingThoughts?: string;      // CoT output (discarded from final)
}

// Assembly types
export interface TransitionGap {
  fromScene: number;
  toScene: number;
  gapType: 'temporal' | 'spatial' | 'emotional';
  severity: 'minor' | 'moderate' | 'severe';
  suggestedBridge?: string;
}

export interface AssemblyResult {
  assembledContent: string;
  transitionGaps: TransitionGap[];
  totalCharacters: number;
  sceneBreakPositions: number[];
}

// Quality Oracle types (full implementation in Plan 02)
export interface QualityAssessment {
  proseQuality: { score: number; verdict: string; issues: string[] };
  sensoryGrounding: { score: number; senseCount: number; required: number };
  filterWordDensity: { count: number; perThousand: number; threshold: number };
  rhythmVariation: { score: number; repetitionInstances: string[] };
  characterVoice: { score: number; driftInstances: string[] };
  transitionQuality: { score: number; issues: string[] };
}

export interface QualityOracleResult {
  verdict: 'PASS' | 'REVISE';
  assessment: QualityAssessment;
  directives: SurgicalDirective[];  // Only populated if verdict is REVISE
  readerExperience: string;         // Qualitative feedback
}

// Default configs
export const DEFAULT_SCENE_WRITER_CONFIG: SceneWriterConfig = {
  maxExemplarsPerScene: 3,
  includeAntiExemplar: true,
  chainOfThoughtEnabled: true,
  targetSceneLength: { min: 800, max: 1500 },
};
```

**schemas/surgical-directive.schema.json:**
Create JSON Schema matching the TypeScript types. Include:
- $schema, $id, title, description
- Required fields: id, type, priority, location, issue, instruction, maxScope
- id pattern: ^dir_[a-z_-]+_[0-9]{3}$
- type enum with all 9 directive types
- priority: integer 1-10
- location object with sceneNumber, paragraphStart, paragraphEnd (required), characterOffset (optional)
- maxScope: integer 1-5
- Optional: currentText, exemplarId, exemplarContent

Use ajv-compatible draft-07 schema like existing schemas in the codebase.
  </action>
  <verify>
1. `npx tsc --noEmit` passes (types compile)
2. `node -e "const Ajv = require('ajv'); const schema = require('./schemas/surgical-directive.schema.json'); new Ajv().compile(schema); console.log('Schema valid')"` succeeds
  </verify>
  <done>
- SurgicalDirective and all 9 DirectiveType values defined
- SceneWriterConfig, SceneDraftResult, AssemblyResult types defined
- QualityOracleResult type defined for Plan 02 integration
- JSON Schema validates directive structure
  </done>
</task>

<task type="auto">
  <name>Task 2: Scene writer orchestration and assembler modules</name>
  <files>
    - src/pipeline/scene-writer.ts
    - src/pipeline/assembler.ts
    - src/pipeline/index.ts
    - tests/pipeline/scene-writer.test.ts
  </files>
  <action>
Implement the scene-by-scene writing orchestration and assembly:

**src/pipeline/scene-writer.ts:**
```typescript
import { SceneV5 } from '../scene/types.js';
import { queryExemplars, ExemplarQuery } from '../style-library/index.js';
import { assembleTieredContext, formatPromptOrder } from '../context/index.js';
import { SceneWriterConfig, SceneDraftResult, DEFAULT_SCENE_WRITER_CONFIG } from './types.js';

export interface SceneWriterOptions {
  scenes: SceneV5[];
  genre: string;
  chapterNumber: number;
  previousChapterEnding?: string;
  config?: Partial<SceneWriterConfig>;
}

// Build exemplar query from scene metadata
export function buildExemplarQuery(scene: SceneV5, genre: string): ExemplarQuery {
  return {
    genre,
    scene_type: mapSceneTypeFromTags(scene.exemplar_tags || []),
    emotional_tone: scene.emotional_arc?.peak_emotion,
    pov: scene.pov_character ? 'third-limited' : undefined,
    pacing: scene.style_override?.pacing,
  };
}

// Map exemplar_tags to scene_type taxonomy
function mapSceneTypeFromTags(tags: string[]): string | undefined {
  const typeMap: Record<string, string> = {
    'opening': 'opening-hook',
    'hook': 'opening-hook',
    'dialogue': 'dialogue',
    'conversation': 'dialogue',
    'action': 'action',
    'fight': 'action',
    'emotional': 'emotional-peak',
    'climax': 'emotional-peak',
    'transition': 'transition',
    'bridge': 'transition',
    'description': 'description',
    'setting': 'description',
  };
  for (const tag of tags) {
    const lower = tag.toLowerCase();
    if (typeMap[lower]) return typeMap[lower];
  }
  return undefined;
}

// Extract last N characters for scene continuity
export function extractEnding(content: string, chars: number): string {
  return content.slice(-chars);
}

// Build scene-specific context items for tiered assembly
export function buildSceneContextItems(
  scene: SceneV5,
  chapterNumber: number,
  exemplars: { exemplars: any[]; anti_exemplar?: any }
): any[] {
  const items: any[] = [];

  // Add scene plan to hot tier
  items.push({
    type: 'scene_plan',
    content: JSON.stringify(scene),
    priority: 100,
    metadata: { sceneNumber: scene.scene_number },
  });

  // Add exemplars to hot tier
  for (const ex of exemplars.exemplars) {
    items.push({
      type: 'exemplar',
      content: ex.content,
      priority: 95,
      metadata: { exemplarId: ex.id, scene_type: ex.scene_type },
    });
  }

  // Add anti-exemplar if present
  if (exemplars.anti_exemplar) {
    items.push({
      type: 'exemplar',
      content: `[ANTI-PATTERN - DO NOT WRITE LIKE THIS]\n${exemplars.anti_exemplar.content}`,
      priority: 90,
      metadata: { exemplarId: exemplars.anti_exemplar.id, isAnti: true },
    });
  }

  return items;
}

// Prepare scene drafting data (agent invocation is external)
export async function prepareSceneDraft(
  scene: SceneV5,
  options: SceneWriterOptions,
  previousSceneEnding: string,
  library: any // StyleLibrary from style-library module
): Promise<{
  scene: SceneV5;
  exemplars: { exemplars: any[]; anti_exemplar?: any };
  contextBundle: any;
  previousEnding: string;
}> {
  const config = { ...DEFAULT_SCENE_WRITER_CONFIG, ...options.config };

  // 1. Build exemplar query
  const query = buildExemplarQuery(scene, options.genre);
  query.limit = config.maxExemplarsPerScene;
  query.include_anti = config.includeAntiExemplar;

  // 2. Fetch exemplars
  const exemplars = queryExemplars(library, query);

  // 3. Build context items
  const contextItems = buildSceneContextItems(scene, options.chapterNumber, exemplars);

  // 4. Assemble tiered context with sandwich pattern
  const contextBundle = assembleTieredContext(contextItems, {
    currentChapter: options.chapterNumber,
    appearsInCurrentScene: true,
  });

  return {
    scene,
    exemplars,
    contextBundle,
    previousEnding: previousSceneEnding,
  };
}

// Orchestrate scene-by-scene preparation (actual drafting via agent)
export async function prepareChapterScenes(
  options: SceneWriterOptions,
  library: any
): Promise<Array<Awaited<ReturnType<typeof prepareSceneDraft>>>> {
  const preparations: Array<Awaited<ReturnType<typeof prepareSceneDraft>>> = [];
  let previousEnding = options.previousChapterEnding || '';

  for (const scene of options.scenes) {
    const prep = await prepareSceneDraft(scene, options, previousEnding, library);
    preparations.push(prep);

    // For next iteration, use placeholder (actual content comes from agent)
    // In real flow, this would be updated after each scene is drafted
    previousEnding = `[Scene ${scene.scene_number} ending placeholder]`;
  }

  return preparations;
}
```

**src/pipeline/assembler.ts:**
```typescript
import { SceneDraftResult, TransitionGap, AssemblyResult } from './types.js';
import { SceneV5 } from '../scene/types.js';

const SCENE_BREAK = '\n\n---\n\n';

// Detect gaps between scenes that need bridging
export function detectTransitionGaps(
  drafts: SceneDraftResult[],
  scenes: SceneV5[]
): TransitionGap[] {
  const gaps: TransitionGap[] = [];

  for (let i = 0; i < drafts.length - 1; i++) {
    const currentScene = scenes[i];
    const nextScene = scenes[i + 1];
    const gapTypes: Array<'temporal' | 'spatial' | 'emotional'> = [];

    // Check temporal gap (different time markers in scene)
    if (currentScene.transition?.to_next?.includes('시간') ||
        nextScene.transition?.from_previous?.includes('시간')) {
      gapTypes.push('temporal');
    }

    // Check spatial gap (location change)
    if (currentScene.location !== nextScene.location) {
      gapTypes.push('spatial');
    }

    // Check emotional discontinuity (exit != next entry)
    const exitEmotion = currentScene.emotional_arc?.exit_emotion;
    const entryEmotion = nextScene.emotional_arc?.entry_emotion;
    if (exitEmotion && entryEmotion && exitEmotion !== entryEmotion) {
      gapTypes.push('emotional');
    }

    // Create gap if 2+ issues detected
    if (gapTypes.length >= 2) {
      gaps.push({
        fromScene: currentScene.scene_number,
        toScene: nextScene.scene_number,
        gapType: gapTypes[0], // Primary gap type
        severity: gapTypes.length >= 3 ? 'severe' : 'moderate',
        suggestedBridge: generateBridgeSuggestion(currentScene, nextScene, gapTypes),
      });
    }
  }

  return gaps;
}

// Generate bridge suggestion based on gap type
function generateBridgeSuggestion(
  from: SceneV5,
  to: SceneV5,
  gapTypes: Array<'temporal' | 'spatial' | 'emotional'>
): string {
  const suggestions: string[] = [];

  if (gapTypes.includes('temporal')) {
    suggestions.push('Add time transition marker (e.g., "한 시간 후", "다음 날 아침")');
  }
  if (gapTypes.includes('spatial')) {
    suggestions.push(`Bridge from ${from.location || 'current'} to ${to.location || 'next'} location`);
  }
  if (gapTypes.includes('emotional')) {
    suggestions.push(`Smooth emotional shift from ${from.emotional_arc?.exit_emotion} to ${to.emotional_arc?.entry_emotion}`);
  }

  return suggestions.join('; ');
}

// Assemble drafted scenes into chapter
export function assembleScenes(
  drafts: SceneDraftResult[],
  scenes: SceneV5[]
): AssemblyResult {
  // Sort by scene number
  const sorted = [...drafts].sort((a, b) => a.sceneNumber - b.sceneNumber);

  // Track scene break positions
  const breakPositions: number[] = [];
  let currentPosition = 0;

  // Join with scene breaks
  const parts: string[] = [];
  for (let i = 0; i < sorted.length; i++) {
    if (i > 0) {
      breakPositions.push(currentPosition);
      currentPosition += SCENE_BREAK.length;
    }
    parts.push(sorted[i].content);
    currentPosition += sorted[i].content.length;
  }

  const assembledContent = parts.join(SCENE_BREAK);

  // Detect transition gaps
  const transitionGaps = detectTransitionGaps(sorted, scenes);

  return {
    assembledContent,
    transitionGaps,
    totalCharacters: assembledContent.length,
    sceneBreakPositions: breakPositions,
  };
}

// Validate assembled chapter meets requirements
export function validateAssembly(result: AssemblyResult): {
  valid: boolean;
  warnings: string[];
} {
  const warnings: string[] = [];

  // Check for severe gaps
  const severeGaps = result.transitionGaps.filter(g => g.severity === 'severe');
  if (severeGaps.length > 0) {
    warnings.push(`${severeGaps.length} severe transition gap(s) need assembly agent attention`);
  }

  // Check total length
  if (result.totalCharacters < 3000) {
    warnings.push(`Chapter too short: ${result.totalCharacters} chars (expected 4000-6000)`);
  }
  if (result.totalCharacters > 8000) {
    warnings.push(`Chapter too long: ${result.totalCharacters} chars (expected 4000-6000)`);
  }

  return {
    valid: severeGaps.length === 0,
    warnings,
  };
}
```

**src/pipeline/index.ts:**
```typescript
// Pipeline module exports
export * from './types.js';
export * from './scene-writer.js';
export * from './assembler.js';
```

**tests/pipeline/scene-writer.test.ts:**
Create comprehensive tests:
1. buildExemplarQuery maps scene tags correctly
2. mapSceneTypeFromTags handles all tag variations
3. extractEnding extracts correct character count
4. buildSceneContextItems includes scene plan, exemplars, anti-exemplar
5. prepareSceneDraft returns complete preparation object
6. detectTransitionGaps identifies temporal/spatial/emotional gaps
7. assembleScenes joins with scene breaks in correct positions
8. validateAssembly catches severe gaps and length issues

Use vitest and follow existing test patterns in tests/style-library/ and tests/scene/.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm test -- --run tests/pipeline/` passes (all scene-writer tests)
3. Import test: `node -e "import('./src/pipeline/index.js').then(m => console.log(Object.keys(m)))"`
  </verify>
  <done>
- Scene writer orchestration prepares scene drafts with exemplar injection
- Assembler combines scenes with transition gap detection
- All Phase 1 infrastructure (queryExemplars, assembleTieredContext, SceneV5) integrated
- Tests verify orchestration logic and assembly correctness
  </done>
</task>

</tasks>

<verification>
1. Pipeline module exports all types and functions
2. TypeScript compiles without errors
3. JSON Schema validates surgical directives
4. Scene writer correctly queries Phase 1 Style Library
5. Assembler detects transition gaps between scenes
6. All tests pass
</verification>

<success_criteria>
- [ ] SurgicalDirective type with 9 directive types defined
- [ ] SceneWriterConfig, SceneDraftResult, AssemblyResult types complete
- [ ] JSON Schema validates directive structure
- [ ] Scene writer integrates queryExemplars from Phase 1
- [ ] Scene writer integrates assembleTieredContext from Phase 1
- [ ] Assembler detects temporal, spatial, emotional gaps
- [ ] All tests pass
- [ ] Ready for Quality Oracle integration in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-pipeline/02-01-SUMMARY.md`
</output>
