---
phase: 02-core-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/pipeline/quality-oracle.ts
  - src/pipeline/prose-surgeon.ts
  - src/pipeline/revision-loop.ts
  - src/pipeline/index.ts
  - agents/quality-oracle.md
  - agents/prose-surgeon.md
  - tests/pipeline/quality-oracle.test.ts
  - tests/pipeline/revision-loop.test.ts
autonomous: true

must_haves:
  truths:
    - "Quality evaluation produces passage-level surgical directives"
    - "Directives include location, problem, concrete fix, and exemplar reference"
    - "Prose Surgeon executes only specific fixes identified by Quality Oracle"
    - "Prose Surgeon never rewrites more than 3 paragraphs at once"
    - "Maximum 5 directives per evaluation pass"
    - "Revision loop orchestrates Oracle -> Surgeon cycles with circuit breaker"
  artifacts:
    - path: "src/pipeline/quality-oracle.ts"
      provides: "Directive generation from chapter analysis"
      exports: ["analyzeChapter", "countFilterWords", "countUniqueSenses", "findRhythmIssues", "createDirective"]
    - path: "src/pipeline/prose-surgeon.ts"
      provides: "Directive execution with scope constraints"
      exports: ["executeDirective", "validateScopeCompliance", "applySurgicalFix"]
    - path: "src/pipeline/revision-loop.ts"
      provides: "Oracle -> Surgeon orchestration with circuit breaker"
      exports: ["runRevisionLoop", "RevisionLoopConfig", "RevisionLoopResult"]
    - path: "agents/quality-oracle.md"
      provides: "Opus-based evaluator agent prompt"
      contains: "SurgicalDirective output format"
    - path: "agents/prose-surgeon.md"
      provides: "Opus/Sonnet surgeon agent prompt"
      contains: "maxScope hard constraint"
  key_links:
    - from: "src/pipeline/quality-oracle.ts"
      to: "src/pipeline/types.ts"
      via: "SurgicalDirective import"
      pattern: "import.*SurgicalDirective.*from.*types"
    - from: "src/pipeline/prose-surgeon.ts"
      to: "src/pipeline/types.ts"
      via: "SurgicalDirective import"
      pattern: "import.*SurgicalDirective.*from.*types"
    - from: "src/pipeline/revision-loop.ts"
      to: "src/pipeline/quality-oracle.ts"
      via: "analyzeChapter import"
      pattern: "import.*analyzeChapter.*from.*quality-oracle"
    - from: "src/pipeline/revision-loop.ts"
      to: "src/pipeline/prose-surgeon.ts"
      via: "applySurgicalFix import"
      pattern: "import.*applySurgicalFix.*from.*prose-surgeon"
    - from: "agents/quality-oracle.md"
      to: "schemas/surgical-directive.schema.json"
      via: "output schema reference"
      pattern: "surgical-directive.schema.json"
---

<objective>
Create the Quality Oracle directive system and Prose Surgeon agent: the Oracle analyzes chapter prose and produces passage-level surgical directives (location, problem, fix, exemplar), while the Surgeon executes only those specific fixes with hard scope limits (never more than 3 paragraphs). Also create the revision-loop orchestrator that connects Oracle analysis to Surgeon execution.

Purpose: Replace abstract numeric scoring with actionable, passage-level feedback that enables targeted surgical revision instead of full rewrites.

Output: Quality Oracle module and agent, Prose Surgeon module and agent, revision-loop orchestrator, integrated with Plan 01's directive types.

**DEPRECATION NOTE:** The quality-oracle supersedes agents/critic.md (evaluation function). The prose-surgeon supersedes agents/editor.md (prose refinement function). The legacy agents remain for backward compatibility but new code should use the pipeline modules.
</objective>

<execution_context>
@C:\Users\jodnr\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jodnr\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-pipeline/02-RESEARCH.md

# Plan 01 types (dependency)
@src/pipeline/types.ts

# Phase 1 infrastructure
@src/style-library/retrieval.ts
@src/scene/types.ts

# Legacy agents (DEPRECATED - superseded by quality-oracle and prose-surgeon)
@agents/critic.md
@agents/editor.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Quality Oracle module and agent</name>
  <files>
    - src/pipeline/quality-oracle.ts
    - agents/quality-oracle.md
    - tests/pipeline/quality-oracle.test.ts
    - src/pipeline/index.ts (update exports)
  </files>
  <action>
Create the Quality Oracle that analyzes chapters and produces surgical directives:

**src/pipeline/quality-oracle.ts:**
```typescript
import {
  SurgicalDirective,
  DirectiveType,
  PassageLocation,
  QualityOracleResult,
  QualityAssessment,
} from './types.js';
import { SceneV5 } from '../scene/types.js';

// Korean filter words to detect
const FILTER_WORDS = [
  '느꼈다', '느껴졌다', '느낄 수 있었다',
  '보였다', '보이는 것 같았다',
  '생각했다', '생각이 들었다',
  '깨달았다', '알 수 있었다',
  '~인 것 같았다', '것처럼 보였다',
  '들렸다', '들리는 것 같았다',
];

// Sensory categories for detection
const SENSORY_KEYWORDS: Record<string, string[]> = {
  sight: ['보', '눈', '빛', '색', '어둠', '밝', '반짝', '빤히', '흐릿'],
  sound: ['소리', '들', '울', '속삭', '고함', '웅성', '조용', '시끄러'],
  smell: ['냄새', '향', '코', '맡', '악취', '향기', '퀴퀴'],
  touch: ['만지', '촉감', '따뜻', '차가', '부드러', '거칠', '아프', '따끔'],
  taste: ['맛', '달', '짜', '쓴', '신', '입안', '혀', '삼키'],
};

// Count filter words in text (excluding quoted dialogue)
export function countFilterWords(text: string): { count: number; instances: string[] } {
  // Remove dialogue (quoted text) to avoid false positives
  const withoutDialogue = text.replace(/"[^"]*"/g, '').replace(/'[^']*'/g, '');

  const instances: string[] = [];
  for (const word of FILTER_WORDS) {
    const regex = new RegExp(word.replace(/~/g, '.'), 'g');
    const matches = withoutDialogue.match(regex);
    if (matches) {
      instances.push(...matches);
    }
  }

  return { count: instances.length, instances };
}

// Count unique senses in text
export function countUniqueSenses(text: string): { count: number; senses: string[] } {
  const foundSenses: string[] = [];

  for (const [sense, keywords] of Object.entries(SENSORY_KEYWORDS)) {
    for (const keyword of keywords) {
      if (text.includes(keyword)) {
        if (!foundSenses.includes(sense)) {
          foundSenses.push(sense);
        }
        break;
      }
    }
  }

  return { count: foundSenses.length, senses: foundSenses };
}

// Find rhythm issues (consecutive same-ending sentences)
export function findRhythmIssues(paragraphs: string[]): Array<{
  paragraphIndex: number;
  consecutiveCount: number;
  ending: string;
}> {
  const issues: Array<{ paragraphIndex: number; consecutiveCount: number; ending: string }> = [];

  for (let pIdx = 0; pIdx < paragraphs.length; pIdx++) {
    const sentences = paragraphs[pIdx]
      .split(/[.?!。]/)
      .map(s => s.trim())
      .filter(s => s.length > 0);

    let consecutive = 1;
    let lastEnding = '';

    for (let i = 0; i < sentences.length; i++) {
      const ending = sentences[i].slice(-2); // Last 2 chars (Korean endings)

      if (ending === lastEnding) {
        consecutive++;
      } else {
        if (consecutive >= 5) {
          issues.push({
            paragraphIndex: pIdx,
            consecutiveCount: consecutive,
            ending: lastEnding,
          });
        }
        consecutive = 1;
      }
      lastEnding = ending;
    }

    // Check final sequence
    if (consecutive >= 5) {
      issues.push({
        paragraphIndex: pIdx,
        consecutiveCount: consecutive,
        ending: lastEnding,
      });
    }
  }

  return issues;
}

// Split chapter into paragraphs
export function splitIntoParagraphs(chapter: string): string[] {
  return chapter.split(/\n\n+/).filter(p => p.trim().length > 0);
}

// Create directive with ID generation
let directiveCounter = 0;
export function createDirective(
  type: DirectiveType,
  priority: number,
  location: PassageLocation,
  issue: string,
  instruction: string,
  currentText: string,
  maxScope: number,
  exemplarId?: string,
  exemplarContent?: string
): SurgicalDirective {
  directiveCounter++;
  const typeSlug = type.replace(/-/g, '_');
  const id = `dir_${typeSlug}_${String(directiveCounter).padStart(3, '0')}`;

  return {
    id,
    type,
    priority,
    location,
    issue,
    currentText,
    instruction,
    maxScope,
    exemplarId,
    exemplarContent,
  };
}

// Reset directive counter (for testing)
export function resetDirectiveCounter(): void {
  directiveCounter = 0;
}

// Extract text for a specific scene
export function extractSceneText(chapter: string, sceneNumber: number, scenes: SceneV5[]): string {
  const paragraphs = splitIntoParagraphs(chapter);
  // Simple heuristic: divide paragraphs equally among scenes
  const scenesCount = scenes.length;
  const paragraphsPerScene = Math.ceil(paragraphs.length / scenesCount);
  const startIdx = (sceneNumber - 1) * paragraphsPerScene;
  const endIdx = Math.min(startIdx + paragraphsPerScene, paragraphs.length);

  return paragraphs.slice(startIdx, endIdx).join('\n\n');
}

// Main analysis function
export function analyzeChapter(
  chapter: string,
  scenes: SceneV5[],
  exemplarLibrary?: { getExemplarById?: (id: string) => any }
): QualityOracleResult {
  const directives: SurgicalDirective[] = [];
  const paragraphs = splitIntoParagraphs(chapter);
  const totalChars = chapter.length;

  // 1. Check sensory grounding (2+ senses per 500 chars per scene)
  for (const scene of scenes) {
    const sceneText = extractSceneText(chapter, scene.scene_number, scenes);
    const { count: senseCount, senses } = countUniqueSenses(sceneText);

    if (senseCount < 2 && sceneText.length >= 500) {
      const missingSenses = Object.keys(SENSORY_KEYWORDS).filter(s => !senses.includes(s));
      directives.push(createDirective(
        'sensory-enrichment',
        2, // High priority
        {
          sceneNumber: scene.scene_number,
          paragraphStart: 1,
          paragraphEnd: Math.min(3, paragraphs.length),
        },
        `Scene ${scene.scene_number} has only ${senseCount} sense(s): ${senses.join(', ')}. Need 2+ senses per scene.`,
        `Add sensory details for: ${missingSenses.slice(0, 2).join(', ')}. Ground the reader in the physical experience.`,
        sceneText.slice(0, 200) + '...',
        2, // Max 2 paragraphs for sensory enrichment
      ));
    }
  }

  // 2. Check filter word density (< 5 per 1000 chars)
  const { count: filterCount, instances } = countFilterWords(chapter);
  const filterDensity = (filterCount / totalChars) * 1000;

  if (filterDensity > 5) {
    // Find paragraphs with filter words
    for (let pIdx = 0; pIdx < paragraphs.length && directives.length < 5; pIdx++) {
      const pFilterResult = countFilterWords(paragraphs[pIdx]);
      if (pFilterResult.count > 0) {
        directives.push(createDirective(
          'filter-word-removal',
          3,
          {
            sceneNumber: Math.ceil((pIdx + 1) / Math.max(1, paragraphs.length / scenes.length)),
            paragraphStart: pIdx + 1,
            paragraphEnd: pIdx + 1,
          },
          `Filter words found: ${pFilterResult.instances.join(', ')}`,
          'Remove filter words. Show the sensation/thought directly instead of telling the reader the character felt/thought it.',
          paragraphs[pIdx].slice(0, 150) + '...',
          1, // Single paragraph for filter word removal
        ));
      }
    }
  }

  // 3. Check rhythm variation (no 5+ consecutive same endings)
  const rhythmIssues = findRhythmIssues(paragraphs);
  for (const issue of rhythmIssues) {
    if (directives.length >= 5) break;

    directives.push(createDirective(
      'rhythm-variation',
      4,
      {
        sceneNumber: Math.ceil((issue.paragraphIndex + 1) / Math.max(1, paragraphs.length / scenes.length)),
        paragraphStart: issue.paragraphIndex + 1,
        paragraphEnd: issue.paragraphIndex + 1,
      },
      `${issue.consecutiveCount} consecutive sentences end with "${issue.ending}"`,
      'Vary sentence endings. Mix short impactful sentences with longer flowing ones. Change verb forms, add questions, use fragments strategically.',
      paragraphs[issue.paragraphIndex]?.slice(0, 150) + '...' || '',
      2, // Max 2 paragraphs for rhythm fixes
    ));
  }

  // Prioritize and cap at 5 directives
  const prioritized = directives
    .sort((a, b) => a.priority - b.priority)
    .slice(0, 5);

  // Build assessment
  const senseCheck = countUniqueSenses(chapter);
  const assessment: QualityAssessment = {
    proseQuality: {
      score: filterDensity < 3 ? 8 : filterDensity < 5 ? 6 : 4,
      verdict: filterDensity < 5 ? 'Good' : 'Needs improvement',
      issues: instances.slice(0, 5),
    },
    sensoryGrounding: {
      score: senseCheck.count >= 4 ? 10 : senseCheck.count >= 2 ? 7 : 4,
      senseCount: senseCheck.count,
      required: 2,
    },
    filterWordDensity: {
      count: filterCount,
      perThousand: Math.round(filterDensity * 10) / 10,
      threshold: 5,
    },
    rhythmVariation: {
      score: rhythmIssues.length === 0 ? 10 : rhythmIssues.length < 3 ? 6 : 3,
      repetitionInstances: rhythmIssues.map(i => `${i.consecutiveCount}x "${i.ending}" in para ${i.paragraphIndex + 1}`),
    },
    characterVoice: {
      score: 7, // Default - actual analysis requires agent
      driftInstances: [],
    },
    transitionQuality: {
      score: 7, // Default - actual analysis requires agent
      issues: [],
    },
  };

  return {
    verdict: prioritized.length > 0 ? 'REVISE' : 'PASS',
    assessment,
    directives: prioritized,
    readerExperience: prioritized.length === 0
      ? 'Prose meets quality standards. Engaging and well-crafted.'
      : `Found ${prioritized.length} areas for improvement. Primary focus: ${prioritized[0]?.type || 'none'}.`,
  };
}
```

**agents/quality-oracle.md:**
Create agent prompt with:
- name: quality-oracle
- description: 한국어 소설 품질 평가 및 수술 지시 생성. critic.md를 대체합니다.
- model: opus
- tools: Read, Glob, Grep (READ-ONLY)

Role section:
- Professional Korean prose quality evaluator
- Produces passage-level surgical directives, not numeric scores
- READ-ONLY: evaluates and produces directives, does NOT edit
- **Supersedes agents/critic.md** for new pipeline code

Critical Constraints:
- Maximum 5 directives per evaluation
- Each directive must have: type, location (scene/paragraph), issue, instruction, maxScope
- Priority ordering: show-not-tell (1) > sensory (2) > filter-word (3) > rhythm (4) > others
- Include exemplar reference for sensory-enrichment and show-not-tell directives
- If more than 5 issues found, recommend re-generation instead of revision

**Agent Invocation Workflow:**
```
## How This Agent Is Invoked

1. **Caller** provides chapter file path and scene metadata
2. **Agent reads** the chapter content via Read tool
3. **Agent calls** analyzeChapter() internally or performs equivalent analysis
4. **Agent outputs** QualityOracleResult JSON:
   - verdict: 'PASS' | 'REVISE'
   - assessment: QualityAssessment object
   - directives: SurgicalDirective[] (max 5)
   - readerExperience: qualitative feedback

## Input Format (from caller)
```json
{
  "chapter_path": "chapters/chapter_1_draft.md",
  "scenes": [SceneV5[], ...],
  "exemplar_library_path": ".novel/style-library/library.json"
}
```

## Output Format
```json
{
  "verdict": "REVISE",
  "assessment": { ... },
  "directives": [
    {
      "id": "dir_sensory_enrichment_001",
      "type": "sensory-enrichment",
      "priority": 2,
      "location": { "sceneNumber": 1, "paragraphStart": 1, "paragraphEnd": 2 },
      "issue": "Scene 1 has only 1 sense(s): sight. Need 2+ senses per scene.",
      "instruction": "Add sensory details for: sound, touch.",
      "currentText": "...",
      "maxScope": 2
    }
  ],
  "readerExperience": "Found 3 areas for improvement."
}
```
```

Guidelines with:
- Diagnostic metrics computation (sensory count, filter density, rhythm check)
- Directive type decision tree
- Korean-specific quality markers
- Output format: QualityOracleResult JSON matching schema

Include reference to surgical-directive.schema.json for directive format.

**tests/pipeline/quality-oracle.test.ts:**
Test cases:
1. countFilterWords detects filter words outside dialogue
2. countFilterWords ignores filter words in quoted dialogue
3. countUniqueSenses identifies all 5 sense categories
4. findRhythmIssues detects 5+ consecutive same endings
5. createDirective generates correct ID pattern
6. analyzeChapter caps directives at 5
7. analyzeChapter returns PASS when no issues
8. analyzeChapter returns REVISE with directives when issues found
9. extractSceneText divides chapter correctly

Update src/pipeline/index.ts to export quality-oracle functions.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm test -- --run tests/pipeline/quality-oracle` passes
3. Agent file has correct frontmatter: `head -10 agents/quality-oracle.md`
4. Agent file contains invocation workflow: `grep -c "Agent Invocation Workflow" agents/quality-oracle.md`
  </verify>
  <done>
- Quality Oracle analyzes prose for sensory, filter word, rhythm issues
- Produces max 5 prioritized surgical directives
- Korean filter word detection excludes dialogue
- Agent prompt guides opus-based evaluation with explicit invocation workflow
- Tests verify all detection and directive generation logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Prose Surgeon module and agent</name>
  <files>
    - src/pipeline/prose-surgeon.ts
    - agents/prose-surgeon.md
    - tests/pipeline/prose-surgeon.test.ts
    - src/pipeline/index.ts (update exports)
  </files>
  <action>
Create the Prose Surgeon that executes surgical directives with scope constraints:

**src/pipeline/prose-surgeon.ts:**
```typescript
import { SurgicalDirective, DirectiveType } from './types.js';

// Model routing by directive type (per RESEARCH.md)
export const MODEL_ROUTING: Record<DirectiveType, { model: string; temperature: number }> = {
  'show-not-tell': { model: 'opus', temperature: 0.6 },
  'filter-word-removal': { model: 'sonnet', temperature: 0.3 },
  'sensory-enrichment': { model: 'opus', temperature: 0.6 },
  'rhythm-variation': { model: 'sonnet', temperature: 0.4 },
  'dialogue-subtext': { model: 'opus', temperature: 0.7 },
  'cliche-replacement': { model: 'opus', temperature: 0.5 },
  'transition-smoothing': { model: 'sonnet', temperature: 0.4 },
  'voice-consistency': { model: 'opus', temperature: 0.5 },
  'proofreading': { model: 'haiku', temperature: 0.2 },
};

// Maximum scope limits by directive type
export const MAX_SCOPE_LIMITS: Record<DirectiveType, number> = {
  'show-not-tell': 3,
  'filter-word-removal': 5,
  'sensory-enrichment': 2,
  'rhythm-variation': 5,
  'dialogue-subtext': 3,
  'cliche-replacement': 3,
  'transition-smoothing': 2,
  'voice-consistency': 3,
  'proofreading': 999, // Unlimited for proofreading
};

// Validate directive scope compliance
export function validateScopeCompliance(directive: SurgicalDirective): {
  valid: boolean;
  error?: string;
} {
  const maxAllowed = MAX_SCOPE_LIMITS[directive.type];
  const requestedScope = directive.location.paragraphEnd - directive.location.paragraphStart + 1;

  if (requestedScope > maxAllowed) {
    return {
      valid: false,
      error: `Directive ${directive.id} requests ${requestedScope} paragraphs but ${directive.type} allows max ${maxAllowed}`,
    };
  }

  if (directive.maxScope > maxAllowed) {
    return {
      valid: false,
      error: `Directive ${directive.id} has maxScope ${directive.maxScope} but ${directive.type} allows max ${maxAllowed}`,
    };
  }

  return { valid: true };
}

// Extract target paragraphs from chapter
export function extractTargetParagraphs(
  chapter: string,
  location: SurgicalDirective['location']
): { paragraphs: string[]; startIndex: number; endIndex: number } {
  const allParagraphs = chapter.split(/\n\n+/);
  const startIndex = location.paragraphStart - 1; // 1-indexed to 0-indexed
  const endIndex = location.paragraphEnd; // exclusive

  return {
    paragraphs: allParagraphs.slice(startIndex, endIndex),
    startIndex,
    endIndex,
  };
}

// Apply surgical fix to chapter (replace specific paragraphs)
export function applySurgicalFix(
  chapter: string,
  location: SurgicalDirective['location'],
  fixedContent: string
): { result: string; paragraphsChanged: number } {
  const allParagraphs = chapter.split(/\n\n+/);
  const startIndex = location.paragraphStart - 1;
  const endIndex = location.paragraphEnd;
  const originalCount = endIndex - startIndex;

  // Replace target paragraphs with fixed content
  const fixedParagraphs = fixedContent.split(/\n\n+/).filter(p => p.trim());

  const newParagraphs = [
    ...allParagraphs.slice(0, startIndex),
    ...fixedParagraphs,
    ...allParagraphs.slice(endIndex),
  ];

  return {
    result: newParagraphs.join('\n\n'),
    paragraphsChanged: fixedParagraphs.length,
  };
}

// Validate surgeon output didn't exceed scope
export function validateSurgeonOutput(
  directive: SurgicalDirective,
  originalParagraphs: string[],
  fixedParagraphs: string[]
): { valid: boolean; violation?: string } {
  // Check paragraph count
  if (fixedParagraphs.length > directive.maxScope) {
    return {
      valid: false,
      violation: `Output has ${fixedParagraphs.length} paragraphs, exceeds maxScope ${directive.maxScope}`,
    };
  }

  // For proofreading, allow any output
  if (directive.type === 'proofreading') {
    return { valid: true };
  }

  // Check if output is dramatically different (>50% length change indicates rewrite)
  const originalLength = originalParagraphs.join('').length;
  const fixedLength = fixedParagraphs.join('').length;
  const lengthRatio = fixedLength / originalLength;

  if (lengthRatio < 0.5 || lengthRatio > 2.0) {
    return {
      valid: false,
      violation: `Length changed by ${Math.round((lengthRatio - 1) * 100)}%, indicates rewrite not surgical fix`,
    };
  }

  return { valid: true };
}

// Build surgeon prompt for a directive
export function buildSurgeonPrompt(
  directive: SurgicalDirective,
  targetText: string,
  surroundingContext: { before: string; after: string }
): string {
  const parts: string[] = [];

  parts.push(`## Surgical Fix Required\n`);
  parts.push(`**Directive ID:** ${directive.id}`);
  parts.push(`**Type:** ${directive.type}`);
  parts.push(`**Issue:** ${directive.issue}`);
  parts.push(`**Instruction:** ${directive.instruction}`);
  parts.push(`**Max Scope:** ${directive.maxScope} paragraph(s)\n`);

  if (directive.exemplarContent) {
    parts.push(`## Reference Style (Match This):\n${directive.exemplarContent}\n`);
  }

  parts.push(`## Context Before:\n${surroundingContext.before || '[Chapter start]'}\n`);
  parts.push(`## Target Text (FIX THIS):\n${targetText}\n`);
  parts.push(`## Context After:\n${surroundingContext.after || '[Chapter end]'}\n`);

  parts.push(`## Constraints:`);
  parts.push(`- Output ONLY the fixed paragraph(s)`);
  parts.push(`- Do NOT rewrite surrounding context`);
  parts.push(`- Do NOT exceed ${directive.maxScope} paragraph(s)`);
  parts.push(`- Preserve the author's voice and style`);
  parts.push(`- Match the exemplar's technique if provided`);

  return parts.join('\n');
}

// Execution tracking for revision loop
export interface ExecutionRecord {
  directiveId: string;
  iteration: number;
  success: boolean;
  violation?: string;
}

export function shouldCircuitBreak(
  records: ExecutionRecord[],
  directiveId: string
): { break: boolean; reason?: string } {
  const sameDirectiveAttempts = records.filter(r => r.directiveId === directiveId && !r.success);

  if (sameDirectiveAttempts.length >= 3) {
    return {
      break: true,
      reason: `Directive ${directiveId} failed ${sameDirectiveAttempts.length} times. Escalate to user.`,
    };
  }

  return { break: false };
}
```

**agents/prose-surgeon.md:**
Create agent prompt with:
- name: prose-surgeon
- description: Quality Oracle 지시에 따른 정밀 문장 수술. editor.md를 대체합니다.
- model: opus (default, can be overridden per directive type)
- tools: Read, Edit

Role section:
- Surgical prose editor executing specific directives
- NEVER rewrites more than specified paragraphs
- Preserves author's voice while making targeted improvements
- **Supersedes agents/editor.md** for new pipeline code

Critical Constraints (HARD RULES):
1. **Never exceed maxScope**: If directive says 2 paragraphs, touch exactly 2
2. **Preserve surrounding text**: Changes are surgical, not rewriting
3. **Follow exemplar style**: When exemplar provided, match its patterns
4. **One directive at a time**: Execute sequentially
5. **Voice preservation**: Maintain character voice from context

Guidelines with:
- Directive type -> operation mapping
- Korean prose techniques by operation type
- Input format (directive JSON + target text + context)
- Output format (fixed text only, no meta-commentary)

Show-not-tell examples:
- Before: 그녀는 슬픔을 느꼈다.
- After: 그녀의 눈가가 붉어졌다. 손끝이 미세하게 떨렸다.

Filter word removal examples:
- Before: 그는 피곤함을 느꼈다.
- After: 그의 눈꺼풀이 무거웠다.

Scope validation reminder at end: "Count your output paragraphs. If you exceed maxScope, try again."

**tests/pipeline/prose-surgeon.test.ts:**
Test cases:
1. validateScopeCompliance passes valid directives
2. validateScopeCompliance rejects over-scope directives
3. extractTargetParagraphs extracts correct paragraph range
4. applySurgicalFix replaces only target paragraphs
5. validateSurgeonOutput catches paragraph count violations
6. validateSurgeonOutput catches rewrite (>50% length change)
7. buildSurgeonPrompt includes all directive fields
8. buildSurgeonPrompt includes exemplar when provided
9. shouldCircuitBreak triggers after 3 failures
10. MODEL_ROUTING has correct models for each directive type

Update src/pipeline/index.ts to export prose-surgeon functions.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm test -- --run tests/pipeline/prose-surgeon` passes
3. Agent file has correct frontmatter: `head -10 agents/prose-surgeon.md`
  </verify>
  <done>
- Prose Surgeon validates scope before and after execution
- Model routing matches RESEARCH.md recommendations
- Circuit breaker prevents infinite revision loops
- Agent prompt enforces hard scope constraints
- Tests verify all validation and fix application logic
  </done>
</task>

<task type="auto">
  <name>Task 3: Revision loop orchestrator</name>
  <files>
    - src/pipeline/revision-loop.ts
    - tests/pipeline/revision-loop.test.ts
    - src/pipeline/index.ts (update exports)
  </files>
  <action>
Create the revision-loop orchestrator that connects Quality Oracle analysis to Prose Surgeon execution:

**src/pipeline/revision-loop.ts:**
```typescript
import { QualityOracleResult, SurgicalDirective } from './types.js';
import { SceneV5 } from '../scene/types.js';
import { analyzeChapter } from './quality-oracle.js';
import {
  applySurgicalFix,
  validateScopeCompliance,
  validateSurgeonOutput,
  extractTargetParagraphs,
  buildSurgeonPrompt,
  ExecutionRecord,
  shouldCircuitBreak,
  MODEL_ROUTING,
} from './prose-surgeon.js';

export interface RevisionLoopConfig {
  maxIterations: number;        // Default: 3
  maxDirectivesPerPass: number; // Default: 5
  stopOnCircuitBreak: boolean;  // Default: true
  verboseLogging: boolean;      // Default: false
}

export const DEFAULT_REVISION_CONFIG: RevisionLoopConfig = {
  maxIterations: 3,
  maxDirectivesPerPass: 5,
  stopOnCircuitBreak: true,
  verboseLogging: false,
};

export interface RevisionLoopResult {
  finalContent: string;
  iterations: number;
  finalVerdict: 'PASS' | 'REVISE' | 'CIRCUIT_BREAK';
  executionRecords: ExecutionRecord[];
  directivesApplied: number;
  directivesFailed: number;
  circuitBreakReason?: string;
}

// Type for the surgeon callback (agent invocation is external)
export type SurgeonCallback = (
  directive: SurgicalDirective,
  prompt: string,
  modelConfig: { model: string; temperature: number }
) => Promise<string>; // Returns fixed text

/**
 * Run the revision loop: Oracle -> Surgeon -> Oracle -> ...
 *
 * This orchestrator:
 * 1. Calls analyzeChapter to get directives
 * 2. For each directive, builds surgeon prompt and invokes callback
 * 3. Applies surgical fixes to chapter
 * 4. Re-analyzes until PASS or max iterations
 *
 * The actual agent invocation is handled by the callback, allowing
 * the write-scene skill to inject its agent execution mechanism.
 */
export async function runRevisionLoop(
  initialContent: string,
  scenes: SceneV5[],
  surgeonCallback: SurgeonCallback,
  config: Partial<RevisionLoopConfig> = {},
  exemplarLibrary?: any
): Promise<RevisionLoopResult> {
  const cfg = { ...DEFAULT_REVISION_CONFIG, ...config };

  let currentContent = initialContent;
  let iteration = 0;
  const executionRecords: ExecutionRecord[] = [];
  let directivesApplied = 0;
  let directivesFailed = 0;
  let circuitBreakReason: string | undefined;

  while (iteration < cfg.maxIterations) {
    iteration++;

    // 1. Analyze current content
    const oracleResult = analyzeChapter(currentContent, scenes, exemplarLibrary);

    if (cfg.verboseLogging) {
      console.log(`[Revision Loop] Iteration ${iteration}: verdict=${oracleResult.verdict}, directives=${oracleResult.directives.length}`);
    }

    // 2. If PASS, we're done
    if (oracleResult.verdict === 'PASS') {
      return {
        finalContent: currentContent,
        iterations: iteration,
        finalVerdict: 'PASS',
        executionRecords,
        directivesApplied,
        directivesFailed,
      };
    }

    // 3. Process directives
    for (const directive of oracleResult.directives) {
      // Check circuit breaker
      const breakCheck = shouldCircuitBreak(executionRecords, directive.id);
      if (breakCheck.break && cfg.stopOnCircuitBreak) {
        circuitBreakReason = breakCheck.reason;
        return {
          finalContent: currentContent,
          iterations: iteration,
          finalVerdict: 'CIRCUIT_BREAK',
          executionRecords,
          directivesApplied,
          directivesFailed,
          circuitBreakReason,
        };
      }

      // Validate scope compliance
      const scopeCheck = validateScopeCompliance(directive);
      if (!scopeCheck.valid) {
        executionRecords.push({
          directiveId: directive.id,
          iteration,
          success: false,
          violation: scopeCheck.error,
        });
        directivesFailed++;
        continue;
      }

      // Extract target and build prompt
      const { paragraphs: targetParagraphs } = extractTargetParagraphs(
        currentContent,
        directive.location
      );
      const targetText = targetParagraphs.join('\n\n');

      // Get surrounding context
      const allParagraphs = currentContent.split(/\n\n+/);
      const beforeIdx = directive.location.paragraphStart - 2;
      const afterIdx = directive.location.paragraphEnd;
      const surroundingContext = {
        before: beforeIdx >= 0 ? allParagraphs[beforeIdx] : '',
        after: afterIdx < allParagraphs.length ? allParagraphs[afterIdx] : '',
      };

      const prompt = buildSurgeonPrompt(directive, targetText, surroundingContext);
      const modelConfig = MODEL_ROUTING[directive.type];

      try {
        // Invoke surgeon via callback
        const fixedText = await surgeonCallback(directive, prompt, modelConfig);
        const fixedParagraphs = fixedText.split(/\n\n+/).filter(p => p.trim());

        // Validate surgeon output
        const outputCheck = validateSurgeonOutput(directive, targetParagraphs, fixedParagraphs);
        if (!outputCheck.valid) {
          executionRecords.push({
            directiveId: directive.id,
            iteration,
            success: false,
            violation: outputCheck.violation,
          });
          directivesFailed++;
          continue;
        }

        // Apply fix
        const { result } = applySurgicalFix(currentContent, directive.location, fixedText);
        currentContent = result;

        executionRecords.push({
          directiveId: directive.id,
          iteration,
          success: true,
        });
        directivesApplied++;

      } catch (error) {
        executionRecords.push({
          directiveId: directive.id,
          iteration,
          success: false,
          violation: error instanceof Error ? error.message : String(error),
        });
        directivesFailed++;
      }
    }
  }

  // Max iterations reached
  return {
    finalContent: currentContent,
    iterations: iteration,
    finalVerdict: 'REVISE', // Still has issues but hit max iterations
    executionRecords,
    directivesApplied,
    directivesFailed,
  };
}

/**
 * Simple synchronous version for testing without agent callback
 */
export function analyzeAndReport(
  content: string,
  scenes: SceneV5[],
  exemplarLibrary?: any
): QualityOracleResult {
  return analyzeChapter(content, scenes, exemplarLibrary);
}
```

**tests/pipeline/revision-loop.test.ts:**
Test cases:
1. runRevisionLoop returns PASS when no issues
2. runRevisionLoop applies directives and re-checks
3. runRevisionLoop respects maxIterations
4. runRevisionLoop triggers circuit breaker after 3 failures
5. runRevisionLoop tracks execution records correctly
6. runRevisionLoop handles surgeon callback errors gracefully
7. analyzeAndReport returns correct QualityOracleResult

Update src/pipeline/index.ts to export revision-loop functions.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm test -- --run tests/pipeline/revision-loop` passes
3. Import test: `node -e "import('./src/pipeline/index.js').then(m => console.log('runRevisionLoop' in m))"`
  </verify>
  <done>
- Revision loop orchestrates Quality Oracle -> Prose Surgeon cycles
- Circuit breaker prevents infinite loops (3 failures per directive)
- Callback pattern allows skill to inject agent execution
- Execution records track all attempts for debugging
- Ready for write-scene skill integration
  </done>
</task>

</tasks>

<verification>
1. Quality Oracle analyzes chapter and produces max 5 directives
2. Prose Surgeon validates scope compliance
3. Filter word detection excludes dialogue
4. Circuit breaker triggers after 3 failed attempts
5. Revision loop orchestrates Oracle -> Surgeon cycles
6. Agent files have correct frontmatter and invocation workflows
7. All tests pass
</verification>

<success_criteria>
- [ ] Quality Oracle produces passage-level surgical directives
- [ ] Directives capped at 5 per evaluation
- [ ] Prose Surgeon validates maxScope before execution
- [ ] Prose Surgeon validates output doesn't exceed scope
- [ ] Circuit breaker prevents infinite loops
- [ ] Revision loop orchestrates Oracle -> Surgeon -> Oracle cycles
- [ ] Korean filter words detected outside dialogue
- [ ] Agent prompts created with READ-ONLY/surgical constraints
- [ ] Agent prompts include explicit invocation workflows
- [ ] DEPRECATION notes added for critic.md and editor.md
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-pipeline/02-02-SUMMARY.md`
</output>
