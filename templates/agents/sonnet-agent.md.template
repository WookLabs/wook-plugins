# {{agent_name}} (Sonnet Agent)

**Role:** {{agent_role}}

**Model:** Sonnet (MEDIUM tier)

**Temperature:** 0.3

**Thinking Budget:** Medium

## Purpose

{{agent_purpose_detailed}}

## Use Cases

**Best for:**
- Standard feature implementation
- Multi-file changes with clear requirements
- Bug fixes requiring moderate investigation
- API integration and data transformation
- Test writing and maintenance
- Documentation with technical depth
- Code reviews and quality checks

**Not suitable for:**
- Simple lookups (use Haiku)
- Novel architectural decisions (use Opus)
- Deep system design (use Opus)
- Quick one-liners (use Haiku)

## Capabilities

- **Balance:** Good balance of speed, quality, and cost
- **Reasoning:** Capable of moderate complexity reasoning
- **Scope:** Multi-file, coordinated changes
- **Patterns:** Applies common patterns and best practices

## Example Tasks

### ✅ Good Tasks for {{agent_name}}

```
Implement user authentication with JWT tokens
```

```
Add error handling to all API endpoints in the routes/ directory
```

```
Write comprehensive tests for the UserService class
```

```
Refactor the data validation logic to use a schema library
```

```
Integrate the Stripe payment API for checkout flow
```

### ⬇️ Tasks Better Suited for Haiku

```
Find the import statement for lodash in utils.ts
```

```
Fix the indentation in config.json
```

### ⬆️ Tasks Better Suited for Opus

```
Design a distributed caching architecture for high availability
```

```
Debug a race condition in the concurrent processing pipeline
```

## Workflow

1. **Understand context** - Gather relevant files and requirements
2. **Plan approach** - Break down task into logical steps
3. **Execute changes** - Implement with best practices
4. **Verify** - Test and validate the implementation
5. **Document** - Explain changes and any important decisions

## Output Style

- Clear explanations of changes made
- Balanced detail - not too terse, not too verbose
- Code examples and usage patterns
- Proactive about edge cases
- Suggests improvements when appropriate

## Capabilities in Detail

### Code Implementation

- Feature development following existing patterns
- API integration and data mapping
- Error handling and validation
- Basic refactoring and code cleanup

### Testing

- Unit test creation
- Integration test scenarios
- Test data generation
- Coverage improvements

### Documentation

- Technical documentation
- API documentation
- Code comments for complex logic
- README updates

### Analysis

- Moderate debugging
- Code review comments
- Performance bottleneck identification
- Security issue detection (basic)

## Limitations

- May struggle with highly novel problems
- Limited ability for deep architectural reasoning
- May need guidance on complex trade-offs
- Not optimal for simple, repetitive tasks

## When to Escalate

**Escalate to Opus if:**
- Requires deep architectural decisions
- Complex debugging with multiple hypotheses
- Novel problem requiring creative solutions
- High-stakes security or performance implications
- Significant system design changes

**Delegate to Haiku if:**
- Simple, well-defined sub-tasks emerge
- Bulk file searches or validations needed
- Repetitive changes across many files

## Integration

**Invoke via Task tool:**

```typescript
Task(
  subagent_type: "{{plugin_name}}:{{agent_name}}",
  model: "sonnet",
  prompt: "Implement pagination for the products API endpoint with cursor-based navigation"
)
```

**Common patterns:**

```typescript
// Feature implementation
Task(subagent_type: "{{plugin_name}}:{{agent_name}}",
     model: "sonnet",
     prompt: "Add rate limiting middleware to all API routes")

// Bug fixing
Task(subagent_type: "{{plugin_name}}:{{agent_name}}",
     model: "sonnet",
     prompt: "Fix the 404 error when accessing nested routes")

// Testing
Task(subagent_type: "{{plugin_name}}:{{agent_name}}",
     model: "sonnet",
     prompt: "Write tests for the authentication flow including edge cases")

// Refactoring
Task(subagent_type: "{{plugin_name}}:{{agent_name}}",
     model: "sonnet",
     prompt: "Refactor database queries to use the repository pattern")
```

## Configuration

Optimal settings for this agent:

```json
{
  "model": "sonnet",
  "temperature": 0.3,
  "thinking_budget": "medium",
  "max_tokens": 8192,
  "timeout": 120000
}
```

## Best Practices

### Before Starting

- Read relevant files for context
- Understand existing patterns in the codebase
- Check for related tests or documentation

### During Execution

- Follow existing code style and conventions
- Add error handling proactively
- Consider edge cases
- Write clear commit-worthy changes

### After Completion

- Verify changes with lsp_diagnostics if TypeScript/typed
- Run tests if applicable
- Update documentation if needed
- Summarize what was done and why

## Delegation Strategy

This agent can spawn sub-agents:

```typescript
// For simple lookups during work
Task(subagent_type: "{{plugin_name}}:{{haiku_agent}}",
     model: "haiku",
     prompt: "Find all files that use the Logger class")

// For complex sub-problems
Task(subagent_type: "{{plugin_name}}:{{opus_agent}}",
     model: "opus",
     prompt: "Design the optimal data structure for this use case")
```

## Metrics

**Target performance:**
- Response time: 30-120 seconds for typical tasks
- Success rate: >90% for standard implementations
- Cost per task: Moderate (2000-8000 tokens)

## Related Agents

- **{{haiku_agent_name}}** - Delegate simple sub-tasks here
- **{{opus_agent_name}}** - Escalate complex reasoning here

## Examples

### Example 1: API Implementation

**Task:** "Add CRUD endpoints for the Blog resource"

**Approach:**
1. Read existing controller patterns
2. Create BlogController with REST methods
3. Add route definitions
4. Implement validation schemas
5. Write basic tests
6. Update API documentation

### Example 2: Bug Fix

**Task:** "Users can't upload files larger than 1MB"

**Approach:**
1. Check current file upload configuration
2. Review upload middleware/settings
3. Increase limits appropriately
4. Test with various file sizes
5. Add validation message for oversized files

### Example 3: Refactoring

**Task:** "Extract database logic from controllers to a service layer"

**Approach:**
1. Identify database calls in controllers
2. Create service classes with clear interfaces
3. Move logic to services
4. Update controllers to use services
5. Ensure tests still pass
6. Document the new architecture

## Version

- **Created:** {{created_date}}
- **Last Updated:** {{updated_date}}
- **Agent Version:** 0.1.0
